\section{Problema a ser Atacado}

Nos últimos anos sistemas computacionais ganharam cada vez mais espaço no mercado o que acarretou na dedicação de profissionais para manter a qualidade elevada tanto no desenvolvimento como na manutenção destes a fim de proporcionar tanto a multiplataforma quanto que qualquer equipe seja capaz de desenvolvem em qualquer local a qualquer tempo.

Com isso a produção de software tornou-se uma tarefa desafiadora de altíssima complexidade que pode acarretar no aumento da possibilidade de surgimento de problemas. Outro fator de grande relevância é que cada vez mais o bom desempenho do software depende da capacidade e qualificação dos profissionais que compõem a equipe de desenvolvimento. Um desses problemas é manter o desenvolvimento com partes ultrapassadas de uma linguagem o que torna um sistema obsoleto e com a chance de conter {\it bugs} e vulnerabilidades que podem comprometer a segurança de todo o sistema.


A atuação de equipes que desenvolvem utilizando códigos obsoletos continua sendo um grande problema no desenvolvimento de software ao longo de suas \textit{releases}, mesmo com a evolução da linguagem. Códigos mais atuais tornam-se cada vez mais necessário pois evitam, corrigem falhas e vulnerabilidades além do mesmo tornar-se mais atual. Tais códigos não evoluem podem ser por falta de suporte da IDE, por falta conhecimento da equipe de desenvolvedora ou pelo simples fato de não possuir uma analisador estático que aborde estas construções lançadas nas novas versões das linguagens, especificamente java.


Após toda \textit{release} uma linguagem demora um certo tempo de maturação para que comunidade de desenvolvedores adote novas características lançadas ou simplesmente não a utilizem, porém java possui uma filosofia de manter suporte a todos legado já desenvolvido por questão de portabilidade o que beneficia tanto IDE's quanto equipes a não ter a necessidade de se atualizarem para as ultimas versões da linguagem o que torna a construção de software com uma linguagem ultrapassada confortável porém existe a possibilidade do software possuir vulnerabilidades.

Um bom exemplo a ser lembrado \'{e} FORTRAN quando adicionou orienta\c{c}\~{a}o a objetos em sua na sua vers\~{a}o do ano de 2003 for\c{c}ando a evolu\c{c}\~{a}o de seus compiladores os quais n\~{a}o forneciam mais suporte a vers\~{o}es anteriores conforme relata Jeffrey L. Overbey e Ralph E. Johnson em  \cite{Overbey:2009}, que como consequ\^{e}ncia forçou toda comunidade desenvolvedora a se atualizar, contudo inicialmente os compiladores realizava a evolu\c{c}\~{a}o de alguns trechos espec\'{i}ficos de c\'{o}digo em tempo de compila\c{c}\~{a}o por um c\'{o}digo atualizado equivalente ao que foi substituido.

O processo de utilizar um analisador estático em um projeto antes de sua compilação pode vir a impactar na melhora da confiança do software pois pode detectar vulnerabilidades de maneira prematura além de reduzir o retrabalho caso estas não fossem detectadas. Tais vulnerabilidades são falhas que podem vir a ser exploradas por usuários maliciosos, estes podem desde obter acesso ao sistema, manipular dados ou até mesmo tornar todo serviço indisponível. Neste trabalho a criação de um analisador estático terá o intuito de pesquisar trechos de código ultrapassado.

A implementa\c{c}\~{a}o de {\it refactoring} na grande parte das modernas IDEs mant\'{e}m suporte para um simples conjunto de c\'{o}digo onde o comportamento \'{e} intuitivo e f\'{a}cil de ser analisado,  quando caracter\'{i}sticas avan\c{c}adas de uma linguagem com o Java s\~{a}o usadas descrever precisamente o comportamento de tarefas \'{e} de grande complexidade al\'{e}m da implementa\c{c}\~{a}o do \textit{refactoring} ficar complexa e de dif\'{i}cil entendimento segundo Max Schäfer e Oege de Moor em~\cite{Schaefer:ACM2010}. Modernas IDEs como Ecplise realizam complexos \textit{refactoring} atrav\'{e}s da t\'{e}cnica de {\it microrefactoring} que nada mais \'{e} que a divis\~{a}o de um bloco de c\'{o}digo complexo em pequenas partes para tentar encontrar c\'{o}digos mais intuitivos a serem modificados.

O analisador est\'{a}tico proposto nesse trabalho tem o objeto de identificar constru\c{c}\~{o}es ultrapassadas e por\c{c}\~{o}es de c\'{o}digo congelados que s\~{a}o utilizados ao logo do desenvolvimento do software. Verificando ainda o hist\'{o}rico do lan\c{c}amento das {\it releases} de alguns {\it software} livres analisados em especialmente o que foram desenvolvidos na linguagem Java. Ainda caber\'{a} ao desenvolvedor tomar a decis\~{a}o caso existam constru\c{c}\~{o}es ultrapassadas nas \textit{releases} adotar ou {\it refactoring} ou manter o c\'{o}digo congelado podendo a vir expor o software devido a motivos comentados anteriormente.
