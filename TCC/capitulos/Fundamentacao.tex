%\input{capitulos/HistoriaDaLinguagem}
%\input{capitulos/AspectosEvolutivos}
\chapter{Fundamenta\c{c}\~{a}o}

Conforme mencionado no cap\'{i}tulo anterior, o principal objetivo deste trabalho de conclus\~{a}o de curso \'{e} 
identificar oportunidades de evolu\c{c}\~{a}o de c\'{o}digo em projetos que utilizam recursos anteriores a Java 7 e Java 8, 
algo necess\'{a}rio para o contexto de reestrutura\c c\~{a}o de c\'{o}digo que visa adequar um c\'{o}digo 
existente para usar constru\c c\~{o}es mais atuais de uma determinada de linguagem de programa\c c\~{a}o 
(no caso, a linguagem Java). Importante destacar que as vers\~{o}es da linguagem Java mencionadas anteriormente
introduziram novos recursos, tais como: \texttt{multi-catch}, \texttt{try-with-resourse}, \texttt{switch-string} 
e \texttt{lambda expressions}; e que esse tipo de evolu\c{c}\~{a}o constitui uma nova perspectiva de \textit{refactoring}, que se caracteriza 
por uma transforma\c c\~{a}o de c\'{o}digo que preserva comportamento e que passa a usar  
novas constru\c c\~{o}es da linguagem de programa\c c\~{a}o (conforme defendido por Overbey and Johnson~\cite{Overbey:2009}). 

Para atingir o objetivo do trabalho de conclus\~{a}o de curso, foi necess\'{a}rio estudar temas relacionados 
\`{a} evolu\c c\~{a}o da linguagem Java, engenharia de linguagens de software (ou no Ingl\^{e}s Software 
Language Engineering) e refatoramento de c\'{o}digo (\emph{code refactoring}).  Para dar mais clareza ao leitor 
sobre essas tem\'{a}ticas, esse cap\'{i}tulo apresenta uma vis\~{a}o geral sobre esses temas. Note que n\~{a}o foi objetivo
deste trabalho implementar um mecanismo de transforma\c c\~{a}o de c\'{o}digo, mas sim construir um suporte ferramental 
efetivo para compreender como os desenvolvedores usam as constru\c c\~{o}es existentes na linguagem Java e {\bf identificar oportunidades de melhoria de c\'{o}digo}, algo essencial para permitir a atualiza\c c\~{a}o de um c\'{o}digo existente que usa constru\c c\~{o}es ultrapassadas de uma linguagem de programa\c c\~{a}o. 
 
Muito das ocorr\^{e}ncia de c\'{o}digo ultrapassao acontece devido a compatibilidade que a linguagem Java mant\'{e}m em todas entre suas vers\~{o}es, o que pode vir a ser um problema na manuten\c{c}\~{a}o de um software dado diversas vari\'{a}veis que vai desde o conhecimento do desenvolvedor at\'{e} o sistema em que vai executar o software.
 
 
\section{Evolu\c{c}\~{a}o Linguagem Java}\label{sec:evolucaoJava}

Java \'{e} uma linguagem orientada a objetos de proposito geral projetada pela SUN Microsystems para conter poucas depend\^{e}ncias na implementa\c{c}\~{a}o de um software, atualmente e pertence a Oracle (2009). Existem algumas semenlhan\c{c}as em sua sintaxe com \texttt{C/C++} pois estas linguagens influ\^{e}nciaram no desenvolvimento da linguagem Java. Tendo em vista alguns pontos no importantes durante a evolu\c{c}\~{a}o da linguagem Java a Figura:~\ref{fig:timeLineJava} exibe o caracter\'{i}sticas da linguagem que cont\'{e}m  maior relev\^{a}ncia para o desenvolvimento deste trabalho de conclus\~{a}o. Ressaltando ainda que durante a realiza\c{c}\~{a}o deste trabalho a \'{u}ltima vers\~{a}o  da linguagem \'{e} Java 8.

\begin{figure}[h]
	\center
	\includegraphics[scale=1]{Imagens/timeLineJava}
	\label{fig:timeLineJava}
	\caption{Resumo cronol\'{o}gico da linguagem Java.}
\end{figure}

Relativo a independ\^{e}ncia de plataforma a linguegem Java se destaca por permitir que programas desenvolvidos possam ser executados em qualque plataforma tendo em vinda que at\'{e} hoje a portabilidade entre plataformas para alguns software \'{e} de um problema. Java permite tal flexibilidade entre plataformas devido uma m\'{a}quina virtual \acs{JVM} que executa o c\'{o}digo compilado conhecido com \textit{bytecode}, e este pode ser executado em qualquer plataforma que contenha a m\'{a}quina virtual. A Figura:~\ref{fig:portabilidadeJava} exemplifica a principal caracter\'{i}stica da linguagem Java, portabilidade.


\begin{figure}[h]
	\center
	\includegraphics[scale=0.8]{Imagens/portabilidadeJava}
	\label{fig:portabilidadeJava}
	\caption{Portabilidade da liguagem Java.}
\end{figure}

%Conforme mencionado no cap\'{i}tulo anterior, 
%o principal objetivo deste trabalho de conclus\~{a}o de curso \'{e} 
%identificar oportunidades de evolu\c{c}\~{a}o de c\'{o}digo 
%em projetos que utilizam recursos anteriores aos dispon\'{i}veis 
%nas vers\~{o}es 7 e 8 da linguagem Java, 
%algo necess\'{a}rio para o contexto de 
%reestrutura\c c\~{a}o de c\'{o}digo que visa adequar um c\'{o}digo 
%existente para usar constru\c c\~{o}es mais atuais 
%de uma determinada de linguagem de programa\c c\~{a}o 
%(no caso, a linguagem Java). Importante destacar 
%que as vers\~{o}es da linguagem Java mencionadas anteriormente
%introduziram novos recursos, tais como: 
%\texttt{multi-catch}, \texttt{try-with-resource}, \texttt{switch-string} 
%e \texttt{lambda expressions}; e que esse tipo de 
%evolu\c{c}\~{a}o constitui uma nova perspectiva 
%de \textit{refactoring}, que se caracteriza 
%por uma transforma\c c\~{a}o de c\'{o}digo que 
%preserva comportamento e que passa a usar  
%novas constru\c c\~{o}es da linguagem de programa\c c\~{a}o 
%(conforme defendido por Overbey and Johnson~\cite{Overbey:2009}). 
%
%Para atingir o objetivo do trabalho de conclus\~{a}o de curso, 
%foi necess\'{a}rio estudar temas relacionados 
%\`{a} evolu\c c\~{a}o da linguagem Java, engenharia de 
%linguagens de software (ou no Ingl\^{e}s \emph{Software 
%Language Engineering}) e refatoramento de c\'{o}digo 
%(\emph{code refactoring}). Para fornecer uma introdu\c c\~{a}o ao leitor, 
%esse cap\'{i}tulo apresenta 
%uma vis\~{a}o geral sobre esses temas. Note que n\~{a}o foi objetivo
%deste trabalho implementar um mecanismo de transforma\c c\~{a}o 
%de c\'{o}digo, mas sim construir um suporte ferramental 
%efetivo para compreender como os desenvolvedores usam as 
%constru\c c\~{o}es existentes na linguagem Java e {\bf identificar 
%oportunidades de melhoria de c\'{o}digo}, algo essencial para 
%permitir a atualiza\c c\~{a}o de um c\'{o}digo existente 
%que usa constru\c c\~{o}es ultrapassadas de uma 
%linguagem de programa\c c\~{a}o. 
% 
%\section{Evolu\c{c}\~{a}o Linguagem Java}\label{sec:evolucaoJava}



No in\'{i}cio dos anos noventa, um grupo de engenheiros da 
Sun Microsystems, chamados de \textit{Green Team}, acreditava 
que a pr\'{o}xima grande \'{a}rea da computa\c{c}\~{a}o 
seria a uni\~{a}o de equipamentos eletroeletr√¥nicos com os 
computadores. O \textit{Green Team}, liderado por James Gosling, 
especificou a linguagem de programa\c{c}\~{a}o Java, 
inicialmente proposta para dispositivos de entretenimento 
como aparelhos de TV a cabo. Por outro lado, apenas em 1995, 
com a massifica\c{c}\~{a}o da Internet, a linguagem Java 
teve sua primeira grande aplica\c{c}\~{a}o: a constru\c{c}\~{a}o 
de componentes de software para o navegador Netscape.

%Java \'{e} uma linguagem de programa\c{c}\~{a}o de prop\'{o}sito geral, 
%orientada a objetos e concebida para ser independente de plataforma, 
%gra\c cas ao uso de uma m\'{a}quina virtual---a 
%\emph{Java Virtual Machine} (JVM). Isso permite 
%que uma aplica\c c\~{a}o Java
%possa ser executada em qualquer ambiente computacional que possui 
%uma JVM aderente \`{a} especifica\c c\~{a}o da linguagem.

Na sua primeira vers\~{a}o publicamente dispon\'{i}vel 
(\acs{JDK} 1.0.2), existiam apenas oito bibliotecas 
presentes na especifica\c c\~{a} Java, tais como 
\texttt{java.lang}, \texttt{java.io}, \texttt{java.util},  
\texttt{java.net}, \texttt{java.awt} e \texttt{java.applet}; 
onde as tr\^{e}s \'{u}ltimas favoreciam a constru\c c\~{a}o de 
solu\c c\~{o}es envolvendo mobilidade de c\'{o}digo:
um componente (um applet Java) poderia ser transferido de um 
servidor para um cliente e, dessa forma, 
ser executado em um navegador Web compat\'{i}vel. As caracter\'{i}sticas de 
independ\^{e}ncia de plataforma e a aproxima\c c\~{a}o com a Web fez 
com que a linguagem Java se tornasse bastante popular, passando a ser 
usada em outros dom\'{i}nios (como o desenvolvimento de software 
para cart\~{o}es inteligentes, para jogos eletr\^{o}nicos e para ambientes corporativos) e a ter 
uma evolu\c c\~{a}o natural com a melhoria de desempenho da 
JVM e a incorpora\c c\~{a}o de um conjunto significativo de 
bibliotecas. 

Apesar de toda essa evolu\c c\~{a}o, que 
trouxe uma r\'{a}pida aceita\c c\~{a}o da linguagem, 
mudan\c cas significativas na especifica\c c\~{a}o 
da sem\^{a}ntica da linguagem s\'{o} se 
tornaram publicamente dispon\'{i}veis em 2004, 
com o lan\c camento da vers\~{a}o intitulada 
Java 5.0 (\emph{Java Language Specification 1.5}). As principais 
contribui\c c\~{o}es para a sem\^{a}ntica da linguagem afetavam 
diretamente a produtividade dos desenvolvedores e incluiam 
implementa\c c\~{o}es mais eficientes de bibliotecas 
existentes (como as bibliotecas de IO e as bibliotecas 
para programa\c c\~{a}o concorrente). Relacionadas \`{a} 
perspectiva sem\^{a}ntica, as principais contribui\c c\~{o}es 
da especifica\c c\~{a}o Java 5.0 introduziram o suporte 
a polimorfismo parametrizado (Java Generics) e enumera\c c\~{o}es; 
o uso de constru\c c\~{o}es \texttt{foreach} para iterar 
sobre cole\c c\~{o}es; a possibilidade de defini\c c\~{a}o de m\'{u}ltiplos 
argumentos com a constru\c c\~{a}o \texttt{varargs} (suportados em 
linguagens como C); e o uso do mecanismo intitulado 
\emph{autoboxing} para converter tipos primitivos nas 
classes Java correspondentes. 
As vers\~{o}es da linguagem Java 7 e Java 8 tamb\'{e}m trouxeram, 
em maior ou menor grau de signific\^{a}ncia, extens\~{o}es sint\'{a}ticas 
e sem\^{a}nticas bastante aguardadas pela comunidade de 
desenvolvedores, tais como:

\begin{description}
\item[Java 7] introduziu em 2011 facilidades como (a) suporte ao tipo \texttt{String} 
em senten\c cas condicionais \texttt{switch}, (b) infer\^{e}ncia de tipos 
na instancia\c c\~{a}o de classes gen\'{e}ricas e (c) captura de 
m\'{u}ltiplos tipos de exce\c c\~{a}o. 

\item[Java 8] introduziu em 2014 o suporte a express\~{o}es lambda e a implementa\c c\~{a}o de 
m\'{e}todos \emph{default} em interfaces Java. O suporte a express\~{o}es lambda pode 
ser compreendido como uma evolu\c c\~{a}o da linguagem t\~{a}o significativo 
quanto a introdu\c c\~{a}o de Java Generics, na vers\~{a}o Java 5. Isso porque 
uma s\'{e}rie de novos idiomas (baseadas em \emph{streaming} para programa\c c\~{a}o 
concorrente) est\~{a}o sendo propostos para a linguagem com base em tal constru\c c\~{a}o.   
\end{description} 


%% Sua segunda vers\~{a}o foi o \acs{JDK}1.1 \cite{JDK1.1} que trouxe ganhos em 
%% funcionalidades, desempenho e qualidade. Novas aplica\c{c}\~{o}es tamb\'{e}m surgiram como : JavaBeans, aprimoramento do \acs{AWT}, novas funcionalidades como o \acs{JDBC}, acesso remoto ao objeto \acs{RMI} e suporte ao padr\~{a}o Unicode 2.0.

%% A terceira vers\~{a}o Java 2 (\acs{JDK} 1.2) ofereceu melhorias significativas no desempenho, um novo modelo de seguran\c{c}a flex\'{i}vel e um conjunto completo de Interface de Programa\c{c}\~{a}o de Aplica\c{c}\~{a}o \acs{API}'s. O modelo de "\textit{sandbox}" foi ampliado para dar aos desenvolvedores, usu\'{a}rios e administradores de sistema a op\c{c}\~{a}o de especificar e gerenciar um conjunto de pol\'{i}ticas de seguran\c{c}a flex\'{i}vel que gerenciam as a\c{c}\~{o}es de uma aplica\c{c}\~{a}o ou \textit{applet} que pode ou n\~{a}o ser executada. Foi introduzido o suporte nativo a \textit{thread} para o ambiente operacional Solaris e tamb\'{e}m a compress\~{a}o de mem\'{o}ria para classes carregadas. Aloca\c{c}\~{a}o de mem\'{o}ria com melhor desempenho e aprimoramento da coleta de lixo. Arquitetura de m\'{a}quina virtual conect\'{a}vel para outras m\'{a}quinas virtuais, incluindo a \textit{Java HotSpot VMNew}. \textit{Java Native Interface }\acs{JNI} de convers\~{a}o. O novo conjunto de componentes de projeto, \acs{GUI} (\textit{Swing}). \acs{API} Java 2D que fornece novos recursos gr\'{a}ficos 2D e \acs{AWT}, bem como suporte para impress\~{a}o. Java \textit{plug-in} para navegadores, fornecendo um tempo de execu\c{c}\~{a}o totalmente compat\'{i}vel com a m\'{a}quina virtual Java amplamente implantadas em navegadores. A inclus\~{a}o do \acs{JDBC} que fornece um acesso mais f\'{a}cil aos dados para consultas mais flex\'{i}veis, suporte ao SQL3 e trouxe melhor desempenho e estabilidade promovidos por cursores de rolagem.


%% Em 8 de Maio de 2000 foi anunciado o Java 2 vers\~{a}o 1.3 que trouxe ganho de desempenho em rela\c{c}\~{a}o a primeira vers\~{a}o da JS2E de cerca de 40\%  no tempo de {\it  start-up}. O {\it Java HotSpot VM} cliente e suas bibliotecas atentando ao desempenho ao fazer o J2SE vers\~{a}o 1.3 a {\it release} o mais r\'{a}pido at\'{e} √† data. Novos recursos, como o {\it caching applet} e instala\c{c}\~{a}o do pacote opcional Java atrav\'{e}s da tecnologia Java {\it  Plug-in} para aumentar a velocidade e a flexibilidade com que os {\it applets} e aplicativos baseados na tecnologia Java podem ser implantados. Java {\it  Plug-in} tecnologia \'{e} um componente do ambiente de execu\c{c}\~{a}o Java 2 que permite Java {\it applets} e aplicativos executarem. O novo suporte para \acs{RSA}, assinatura eletr√¥nica, com um gerenciamento mais confi\'{a}vel e din\^{a}mico, certificados X.509, e verifica\c{c}\~{a}o de arquivos o que significa aumento das possibilidades que os desenvolvedores tem para proteger dados eletr√¥nicos. Uma s\'{e}rie de novos recursos e ferramentas de desenvolvimento da tecnologia J2SE vers\~{a}o 1.3 que permite o desenvolvimento mais f\'{a}cil e r\'{a}pido de aplica\c{c}\~{o}es baseadas na tecnologia {\it web} ou Java {\it  standalone} de alto desempenho. A adi\c{c}\~{a}o de RMI/IIOP e o JNDI para a vers\~{a}o 1.3, melhora na interoperabilidade J2SE. Melhora da conectividade com sistemas de {\it  back-end} que suportam CORBA. O novo suporte que o JNDI fornece acesso aos diret\'{o}rios que suportam o populares LDAP Lightweight Directory Access Protocol, entre outros.


%% No ano de 2002 no dia 6 de Fevereiro, foi lan\c{c}ado a J2SE vers\~{a}o 1.4. Com a vers\~{a}o 1.4, as empresas puderam usar a tecnologia Java para desenvolver aplicativos de neg\'{o}cios mais exigentes e com menos esfor\c{c}o e em menos tempo. As novas funcionalidades como a nova I/O e suporte a 64 bits. A J2SE se tornou plataforma ideal para a minera\c{c}\~{a}o em grande escala de dados, intelig√™ncia de neg\'{o}cios, engenharia e cient\'{i}ficos. A vers\~{a}o 1.4 forneceu suporte aprimorado para tecnologias padr\~{o}es da ind\'{u}stria, tais como SSL, LDAP e CORBA a fim de garantir a operacionalidade em plataformas heterog√™neas, sistemas e ambientes. Com o apoio embutido para XML, a autentica\c{c}\~{a}o avan\c{c}ada, e um conjunto completo de servi\c{c}os de seguran\c{c}a, est\'{a} vers\~{a}o forneceu base para padr\~{o}es de aplica\c{c}\~{o}es Web e servi\c{c}os interoper\'{a}veis. O J2SE avan\c{c}ou para o desenvolvimento de aplicativos de cliente com novos controles de GUI, acelerou Java 2D, a performance gr\'{a}fica, internacionaliza\c{c}\~{a}o e localiza\c{c}\~{a}o expandida de apoio, novas op\c{c}\~{o}es de implanta\c{c}\~{a}o e suporte expandido para o at\'{e} ent\~{a}o {\it Windows XP}.

%% Com a chegada da \acs{JSE2} vers\~{a}o 1.5 (Java 5.0) em 30 de Setembro de 2004, impulsionou benef\'{i}cios extensivos para desenvolvedores, incluindo a facilidade de uso, desempenho global e escalabilidade, monitoramento do sistema e gest\~{a}o e desenvolvimento. O Java 5 foi derivado do trabalho de 15 componentes Java Specification Requests (JSRs) englobando recursos avan\c{c}ados para a linguagem e plataforma. Os l\'{i}deres da ind\'{u}stria na \'{e}poca que participam no grupo de peritos J2SE 5.0 incluiram: Apache Software Foundation, Apple Computer, BEA Systems, Borland Software Corporation, Cisco Systems, Fujitsu Limited, HP, IBM, Macromedia, Nokia Corporation, Oracle, SAP AG, SAS Institute, SavaJe Technologies e Sun Microsystems.

%% Houve novas funcionalidades foram implementadas como: facilidade de desenvolvimento onde os programadores da linguagem Java pode ser mais eficiente e produtivos com os recursos de linguagem Java 5 que permitiram a codifica\c{c}\~{a}o mais segura. Nesta vers\~{a}o surgiu o {\it Generics} ~\cite{OracleGenerics, bracha1998gj}, tipos enumerados, metadados e autoboxing de tipos primitivos permitindo assim uma f\'{a}cil e r\'{a}pida codifica\c{c}\~{a}o. Monitoramento e gest\~{a}o permitindo um foco para a nova vers\~{a}o da plataforma, a aplicativos baseados na tecnologia Java {\it Virtual Machine} que passou a ser monitorado e gerenciado com o {\it built-in} de suporte para Java {\it Management Extensions}. Suporte para sistemas de gest\~{a}o empresarial baseados em SNMP tamb\'{e}m \'{e} vi\'{a}vel. Um olhar novo sobre aplicativos baseado na tecnologia Java padr\~{a}o e proporcionou um melhor desenvolvimento GUI para aplicativos baseados na tecnologia Java. A J2SE 5.0 teve suporte completo a internacionaliza\c{c}\~{a}o e tamb\'{e}m inseriu suporte para acelera\c{c}\~{a}o de hardware por meio da {\it API OpenGL } e tamb\'{e}m para o sistema operacional Solaris e sistemas operacionais da distribui\c{c}\~{a}o Linux. **Maior desempenho e escalabilidade com a nova vers\~{a}o que incluiu melhorias de desempenho, redu\c{c}\~{a}o no tempo de inicializa\c{c}\~{a}o, um menor consumo de mem\'{o}ria e JVM auto ajust\'{a}vel para gerar maior desempenho geral do aplicativo e desenvolvimento em J2SE 5.0 em rela\c{c}\~{a}o a vers\~{o}es anteriores.

%% Java 1.6 (Java 6) foi divulgado em 11 de dezembro de 2006. Tornou o desenvolvimento mais f\'{a}cil, r\'{a}pido e eficiente em termos de custos e ofereceu funcionalidades para servi\c{c}os web, suporte linguagem din\^{a}mica, diagn\'{o}sticos e aplica\c{c}\~{o}es {\it desktop}. Com a chegada dessa nova vers\~{a}o do Java houve combina\c{c}\~{a}o com o {\it NetBeans} IDE 5.5 fornecendo aos desenvolvedores uma estrutura confi\'{a}vel, de c\'{o}digo aberto e compat\'{i}vel, de alta performance para entregar aplicativos baseados na tecnologia Java mais r\'{a}pido e f\'{a}cil do que nunca. O {\it NetBeans} IDE fornece uma fonte aberta e de alto desempenho, modular, extens\'{i}vel, multiplataforma Java IDE para acelerar o desenvolvimento de aplica\c{c}\~{o}es baseadas em software e servi\c{c}os {\it web}. O Java 1.6 ajudou a acelerar a inova\c{c}\~{a}o para o desenvolvedor, aplicativos de colabora\c{c}\~{a}o {\it online} e baseadas na {\it web}, incluindo um novo quadro de desenvolvedores \acs{API}'s para permitir a mistura da tecnologia Java com linguagens de tipagem din\^{a}mica, tais como PHP, Python, Ruby e tecnologia JavaScript. A Sun tamb\'{e}m criou uma cole\c{c}\~{a}o de mecanismos de {\it script} e pr\'{e}-configurado o motor {\it JavaScript Rhino} na plataforma Java. Al\'{e}m disso, o software inclui uma pilha completa de clientes de servi\c{c}os web e suporta as mais recentes especifica\c{c}\~{o}es de servi\c{c}os {\it web}, como \acs{JAX-WS} 2.0, \acs{JAXB} 2.0, \acs{STAX} e \acs{JAXP}. A plataforma Java 1.6 forneceu ferramentas expandidas para o diagn\'{o}stico, gest\~{a}o e monitoramento de aplica\c{c}\~{o}es e tamb\'{e}m inclui suporte para o novo {\it NetBeans Profiler} 5.5 para {\it Solaris DTrace } e, uma estrutura de rastreamento din\^{a}mico abrangente que est\'{a} inclu\'{i}do no sistema operacional Solaris 10. Al\'{e}m disso, o software Java SE 6 aumenta ainda mais a facilidade de desenvolvimento com atualiza\c{c}\~{o}es de interface ferramenta para o {\it Java Virtual Machine} (\acs{JVM}) e o {\it Java Platform Debugger Architecture} (\acs{ACDP}).

%% Java 7 ~\cite{JSE7} foi lan\c{c}ado no dia 28 de julho de 2011. Essa vers\~{a}o foi resultado do desenvolvimento de toda a ind\'{u}stria o que envolveu uma revis\~{a}o de c\'{o}digo aberto e extensa colabora\c{c}\~{a}o entre os engenheiros da {\it Oracle} e membros do ecossistema Java em todo o mundo atrav\'{e}s da comunidade {\it OpenJDK} e do {\it Java Community Process} (\acs{JCP}). Compatibilidade com vers\~{o}es anteriores de Java 7 com vers\~{o}es anteriores da plataforma a fim de preservar os conjuntos de habilidades dos desenvolvedores de software Java e proteger os investimentos em tecnologia Java. As altera\c{c}\~{o}es da linguagem ajudaram a aumentar a produtividade do desenvolvedor e simplificar tarefas comuns de programa\c{c}\~{a}o, reduzindo a quantidade de c\'{o}digo necess\'{a}rio, esclarecendo sintaxe e tornar o c\'{o}digo com mais legibilidade. Melhor suporte para linguagens din\^{a}micas incluindo: Ruby, Python e JavaScript, resultando em aumentos substanciais de desempenho no \acs{JVM}. Uma nova API {\it multicore ready} que permite aos desenvolvedores para se decompor mais facilmente problemas em tarefas que podem ser executadas em paralelo em n\'{u}meros arbitr\'{a}rios de n\'{u}cleos de processador. Uma interface de I/O abrangente para trabalhar com sistemas de arquivos que podem acessar uma ampla gama de atributos de arquivos e oferecem mais informa\c{c}\~{o}es quando ocorrem erros. Novos recursos de rede e de seguran\c{c}a. Suporte expandido para a internacionaliza\c{c}\~{a}o, incluindo suporte a Unicode 6.0. Al\'{e}m de vers\~{o}es atualizadas das bibliotecas padr\~{a}o.

%% Com o lan\c{c}amento do Java SE 8 em 18 de Mar\c{c}o de 2014, permitiu uma maior produtividade e desenvolvimento de aplicativos significativos aumentos de desempenho atrav\'{e}s da redu\c{c}\~{a}o de linhas de c\'{o}digo, {\it collectons} melhoradas, modelos mais simples de programa\c{c}\~{a}o paralela e uso mais eficiente de processadores {\it multi-core}. As principais caracter\'{i}sticas do \acs{JDK} 8 s\~{a}o o projeto Lambda, {\it Nashorn JavaScript Engine}, um conjunto de perfis compactas e a remo\c{c}\~{a}o da "gera\c{c}\~{a}o permanente" do {\it HotSpot Java Virtual Machine} (\acs{JVM}). A \acs{JDK} 8 alcan\c{c}ou desempenho recorde mundial para 4 sistemas de soquete em servidores baseados em Intel e NEC por 2 sistemas de soquete em servidores SPARC da Oracle T5, com uma melhoria de desempenho de 12\% para 41\% em compara\c{c}\~{a}o com o JDK 7 na mesma configura\c{c}\~{a}o de Oracle.

%% %O \acs{JDK} 8 adicionou novas funcionalidades como as express\~{o}es lambda com as seguintes caracter\'{i}sticas: refer√™ncias a m\'{e}todos s\~{a}o compactas e maior legibilidade express\~{o}es lambda para m\'{e}todos que j\'{a} t√™m um nome. M\'{e}todos padr\~{a}o que permitem adicionar novas funcionalidades para as interfaces de suas bibliotecas e assegurar a compatibilidade bin\'{a}ria com o c\'{o}digo escrito para vers\~{o}es mais antigas dessas interfaces. Eles m\'{e}todos de interface que t√™m uma aplica\c{c}\~{a}o e a palavra-chave padr\~{a}o no in\'{i}cio da assinatura do m\'{e}todo. Al\'{e}m disso, pode-se definir m\'{e}todos est\'{a}ticos em interfaces. Novos e aprimorados APIs que se aproveitam de express\~{o}es lambda e dos {\it streams} em Java 8 descrevem as classes novos e aprimorados que se aproveitam de express\~{o}es lambda e {\it streams}. Aprimoramento do compilador Java aproveita digita\c{c}\~{a}o alvo para inferir os par\^{a}metros de tipo de um m\'{e}todo de invoca\c{c}\~{a}o gen\'{e}rica. O tipo de destino de uma express\~{a}o \'{e} o tipo de dados que o compilador Java espera, dependendo de onde a express\~{a}o aparece, por exemplo, pode-se usar o tipo de destino de uma instru\c{c}\~{a}o de atribui\c{c}\~{a}o para o tipo de infer√™ncia em Java 7. No entanto, em Java 8, voc√™ pode usar o tipo de destino para a infer√™ncia de tipos em mais contextos. Anota\c{c}\~{o}es sobre tipos Java onde \'{e} poss\'{i}vel aplicar uma anota\c{c}\~{a}o em qualquer lugar onde um tipo \'{e} usado, utilizado em um conjunto com um sistema de tipo de conector, isso permite a verifica\c{c}\~{a}o de tipo mais forte de seu c\'{o}digo e repeti\c{c}\~{a}o de anota\c{c}\~{o}es que agora \'{e} poss\'{i}vel aplicar o mesmo tipo de anota\c{c}\~{a}o mais de uma vez para a mesma declara\c{c}\~{a}o ou o tipo de utiliza\c{c}\~{a}o.


\section{Engenharia de Linguagens de Software}\label{sec:softEng}


\begin{flushright}
\emph{
\ldots ou engenharia de software para linguagens de programa\c c\~{a}o 
(no Ingl\^{e}s, Software Language Engineering).}
\end{flushright}

A manipula\c{c}\~{a}o de artefatos escritos em 
uma linguagem de programa\c{c}\~{a}o (ou em linguagens de software) 
\'{e} uma tarefa desafiadora, mas que permite o desenvolvimento 
de software aplic\'{a}vel a diferentes cen\'{a}rios, mas que permitem, por exemplo, 
manipular arquivos \texttt{XML}, transformar 
informa\c c\~{o}es e scripts presentes 
em bancos de dados legados, efetuar a tradu\c c\~{a}o de programas 
escritos em uma vers\~{a}o desatualizada de uma linguagem. 

Por envolver diferentes est\'{a}gios, o desenho desse tipo de solu\c c\~{a}o requer, geralmente, 
um estilo arquitetural baseado em um \emph{pipeline},  onde cada est\'{a}gio necess\'{a}rio \`{a}  
 manipula\c{c}\~{a}o de uma linguagem \'{e} implementado como um componente de software. Quando combinados, 
tais componentes proporcionam um programa capaz de realizar a tarefa desejada para realizar o processamento 
de uma ou mais linguagens. A Figura:~\ref{fig:stagesLanguageApp} exibe uma organiza\c c\~{a}o 
t\'{i}pica de componentes para o processamento de artefatos escritos em uma linguagem de 
programa\c c\~{a}o, onde a cada est\'{a}gio do \emph{pipeline}, um componente 
utiliza os resultados do est\'{a}gio anterior para gerar uma sa\'{i}da para o componente 
que realiza o processamento no est\'{a}gio posterior.  

\begin{figure}[h]
  \center
  \includegraphics[scale=0.9]{Imagens/stagesLanguageApp}
  \label{fig:stagesLanguageApp}
  \caption{Fases de aplica\c{c}\~{o}es com linguagens.}
\end{figure}

Existe um esfor\c{c}o consider\'{a}vel para tratar a engenharia de linguagens de programa\c{c}\~{a}o como sendo o desenvolvimento de um software comum. 
Algumas aplica\c{c}\~{o}es t\'{i}picas deste dom\'{i}nio s\~{a}o \texttt{reconhecedores, interpretadores, tradutores e geradores}, 
conforme menciona Terrance Parr~\cite{Parr:2009:LIP:1823613}. 

%% Um \emph{Reconhecedor} \'{e} uma constru\c{c}\~{a}o capaz de receber uma estrutura de dado como um input ou um fluxo de inputs. O fluxo de input pode geralmente \'{e} texto puro mas pode ser utilizado dado bin\'{a}rio. Como exemplo de aplica\c{c}\~{a}o tem-se ferramentas analisadoras de refer√™ncias cruzadas, e ferramentas para carregar classes.

%% \texttt{Interpretador:} Um interpretador, l√™ uma entrada, decodifica e executa as instru\c{c}\~{o}es, interpretadores variam de simples calculadoras at\'{e} a implementa\c{c}\~{a}o de linguagens de programa\c{c}\~{a}o como Java, Python e PHP.

%% \texttt{Tradutor:}A partir um input de texto ou bin\'{a}rio \'{e} emitido uma sa\'{i}da para uma linguagem que pode ser a mesma ou n\~{a}o. √â a combina\c{c}\~{a}o do \textit{reader} e \textit{generator}. Como exemplo tem-se tradutores de linguagens extintas para linguagens atuais, \texttt{refactorers},  gerador de logs e macro pre-processadores.
	
%% \texttt{Gerador:} Percorre uma estrutura de dado e emite uma sa\'{i}da. Como exemplo tem-se ferramentas de mapeamento de objetos relacionais em banco de dados, serializador de objetos, gerador de c\'{o}digo fonte e geradores de p\'{a}gina web.



Al\'{e}m dessas aplica\c c\~{o}es t\'{i}picas, 
ferramentas para a identifica\c c\~{a}o est\'{a}tica de \emph{bugs}, por exemplo, tamb\'{e}m s\~{a}o comumente 
implementadas usando uma organiza\c c\~{a}o como a representada na Figura~\ref{fig:stagesLanguageApp}. 
A ferramenta \textit{FindBugs}~\cite{FindBugs} serve como um exemplo de solu\c c\~{a}o para identifica\c c\~{a}o 
de poss\'{i}veis erros em programas escritos na linguagem Java, a partir do \emph{bytecode} resultante do 
processo de compila\c c\~{a}o. Note na Figura:~\ref{fig:findBugs} a semelhan\c ca arquitetural com as 
abordagens t\'{i}picas para o processamento de artefatos de linguagens de programa\c c\~{a}o. 

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/pipelineFindbugs}
	\label{fig:findBugs}
	\caption{Fase do pipiline do FindBugs.}
\end{figure}


Especificamente no caso deste trabalho, percebeu-se a necessidade de constru\c{c}\~{a}o de um software que 
realiza a an\'{a}lise est\'{a}tica de c\'{o}digo para identificar tanto o uso quanto as oportunidades do uso de constru\c{c}\~{o}es 
sint\'{a}ticas / sem\^{a}nticas da linguagem Java. Em termos arquiteturais, a Figura:~\ref{fig:stagesAnalyzer} ilustra, 
em um alto n\'{i}vel de abstra\c c\~{a}o, os principais componentes que formam o \emph{pipeline} do analisador est\'{a}tico 
implementado nesse trabalho e cujos detalhes de implementa\c c\~{a}o s\~{a}o apresentados no pr\'{o}ximo cap\'{i}tulo.

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/stagesAnalizer}
	\label{fig:stagesAnalyzer}
	\caption{Ferramentas necess\'{a}rias para constru\c{c}\~{a}o do analisador est\'{a}tico.}
\end{figure}

O analisador desenvolvido neste trabalho \'{e} considerado um {\it grammarware} pois \'{e} um software que depende da gram\'{a}tica da linguagem Java para seu funcionamento pois tais softwares devem possum s\'{o}lido conhecimento da  gram\'{a}tica que manipulam. Como exemplos de arquiteturas que possuem tal conhecimento tem-se os programas de convers\~{a}o de dados, processadores de \texttt{XML} e os softwares que efetuam \textit{parses}.

Paul Klint at.al.~\cite{klint2005toward} vai mais al\'{e}m para caracterizar um {\it grammarware} como sendo um software comum, afirmando que este deve  adotar t\'{e}cnicas contempor\^{a}neas a engenharia de software tendo em vista que tais t\'{e}cnicas s\~{a}o utilizadas diariamente no desenvolvimento n\~{a}o sendo nenhuma novidade. A contemporaneidade deste analisador da-se por utilizar t\'{e}cnicas para inje\c{c}\~{a}o de depend\^{e}ncia, controle de dep\^{e}ndencia e  reposit\'{o}rio para manter gerenciamento do software.

Gram\'{a}ticas e software dependentes de gram\'{a}tica n\~{a}o s\~{a}o inven\c{c}\~{o}es recentes e este conceito faz-se presente em \'{a}reas da computa\c{c}\~{a}o como engenharia reversa, desnvolvimento orientado a aspectos, tranforma\c{c}\~{o}es de programas e metamodelagem.

Alguns cen\'{a}rios favorecem o desenvolvimento de softwares {\it grammarware}, onde dentre os diversos cen\'{a}rios pode-se destacar uma aplica\c{c}\~{a}o que necessite importar perfis de usu\'{a}rios para promover a transi\c{c}\~{a}o da vers\~{a}o antiga para uma vers\~{a}o atual. Esta transi\c{c}\~{a}o deve ser robusta e provavelmente necessitar\'{a} de adpta\c{c}\~{a}o o que em muitos casos necessita de um \textit{parser} para partes que necessitam ser adaptadas.

Um outro cen\'{a}rio real \'{e} desenvolvimento de aplica\c{c}\~{o}es de banco de dados onde \'{e} necess\'{a}rio adotar uma nova linguagem de defini\c{c}\~{a}o para um ambiente espec\'{i}fico. De forma que automatizar esta solu\c{c}\~{a}o requer o uso de um \textit{parser} o qual ser\'{a} respons\'{a}vel por identificar os inputs de entrada para efetuar o mapeamento correto para a sa\'{i}da desejada no formato mais atual.

Outro tipo de \textit{software} que manipula a gram\'{a}tica de uma linguagem,s\~{a}o os que realizam \textit{refactoring}. Dentre diversas caracter\'{i}sitas explicadas por Martin Fowler at.al.~\cite{martinFowlerRafactoring}, fica claro que este trabalho contribui com o intu\'{\i}to de identificar constru\c{c}\~{o}es obsoletas e oportunidades para alguma evolu\c{c}\~{a}o e n\~{a}o efetuando \textit{refactoring} de modo autom\'{a}tico mas sim sugerindo ao desenvolvedor escolher pela evolu\c{c}\~{a}o ou n\~{a}o.

A evolu\c{c}\~{a}o do c\'{o}digo para um mais atual \'{e} mais que procurar por \textit{bad smell} onde s\~{a}o ocorr\^{e}ncias pontuais j\'{a} estabelecidas. A oportunidade de evoluir para uma vers\~{a}o mais atual \'{e} muito mais complexa que meramente melhorar o desgin do \textit{software} e por isso essa sugest\~{a}o deve ser apreciada pelo desenvolvedor com cuidado pois pode ser um quest\~{a}o mais profunda. %depender de SO, versao de compilador etc.

Mesmo sem a implementa\c{c}\~{a}o de \textit{refactoring} uma contribui\c{c}\~{a}o que este trabalho faz \'{e} a identifi\c{c}\~{a}o a capacidade de encontrar c\'{o}digo duplicado como por exemplo ao identificar \texttt{catch} repetidos, ou at\'{e} mesmo melhorar o desempenho com no caso da da utiliza\c{c}\~{a}o do \texttt{switch-string} ao inv\'{e}s do \texttt{if-string} pois oracle afirma que o desempenho \'{e} melhor de a implementa\c{c}\~{a}o otimizada do \texttt{switch-string} na documenta\c{c}\~{a}o~\cite{docSwitch}.




%Pode-se compreender este analisador como um \emph{grammarware}~\cite{} pois \'{e} um software 
%que depende fortemente de uma gram\'{a}tica para seu funcionamento--- neste caso a gram\'{a}tica da linguagem Java. 
%%\emph{Grammawares} demandam um conhecimento essencial das  gram\'{a}ticas que manipulam. 
%%Como exemplos de arquiteturas que possuem tal conhecimento tem-se os programas de convers\~{a}o de dados, processadores de \texttt{XML} e os que efetuam \textit{parses}.
%De acordo com~\cite{}, alguns cen\'{a}rios favorecem o desenvolvimento de softwares alinhados com a abordagem 
%\emph{grammarware}, com destaque \`{a}s aplica\c{c}\~{o}es que necessitam importar perfis de usu\'{a}rios para promover a transi\c{c}\~{a}o da vers\~{a}o 
%antiga para uma vers\~{a}o nova {\color{red}[rba] n\~{a}o consegui entender bem essa senten\c ca}. 
%Esta transi\c{c}\~{a}o deve ser robusta e provavelmente necessitar\'{a} de adpta\c{c}\~{a}o dever\'{a} passar 
%por um parser para que as partes que necessitem de adapta\c{c}\~{a}o possam ser identificadas.
%
%Um outro cen\'{a}rio real \'{e} o desenvolvimento de aplica\c{c}\~{o}es de banco de dados onde se faz necess\'{a}rio adotar 
%uma nova linguagem de defini\c{c}\~{a}o para um ambiente espec\'{i}fico. De forma que automatizar esta solu\c{c}\~{a}o requer o uso de um 
%parser que ser\'{a} respons\'{a}vel por reconhecer as entradas necess\'{a}rias para efetuar o mapeamento 
%para a \emph{linguagem} destino.


%% Um \textit{software} que efeta manipula\c{c}\~{a}o da gram\'{a}tica de uma linguagem, como no caso deste trabalho de conclus\~{a}o fica evidente o aparecimento da quest\~{a}o sobre \textit{refactoring} e dentre diversas caracter\'{i}sitas explicadas por Martin Fowler~\cite{martinFowlerRafactoring}, fica claro que este trabalho contribui com o intu\'{\i}to de identificar constru\c{c}\~{o}es obsoletas n\~{a}o efetuando \textit{refactoring} autom\'{a}tico mas fazendo  com que o desenvolvedor opte pela evolu\c{c}\~{a}o ou n\~{a}o. Pois a evolu\c{c}\~{a}o do c\'{o}digo por um mais atual \'{e} uma das oportunidades de melhorar o desgin do \textit{software} conforme aborda por Martin Fowler~\cite{martinFowlerRafactoring} em seu livro.

%% Mesmo sem a implementa\c{c}\~{a}o de \textit{refactoring} uma contribui\c{c}\~{a}o que este trabalho faz \'{e} a identifi\c{c}\~{a}o a capacidade de encontrar c\'{o}digo duplicado como por exemplo ao identificar \texttt{catch} repetidos, ou at\'{e} mesmo melhorar o desempenho com no caso da da utiliza\c{c}\~{a}o do \texttt{switch-string} ao inv\'{e}s do \texttt{if-string} pois oracle afirma que o desempenho \'{e} melhor de a implementa\c{c}\~{a}o otimizada do \texttt{switch-string} na documenta\c{c}\~{a}o~\cite{docSwitch}.




%Atualmente a evolu\c{c}\~{a}o de uma linguagem de programa\c{c}\~{a}o ocorre predominantemente de forma {\it ad-hoc} e em muitos casos manualmente, para a tradu\c{c}\~{a}o de aplicativos legados, conforme a demanda. A ferramentas de an\'{a}lise para gerar a evolu\c{c}\~{a}o necess\'{a}ria, {\it grammarware}, tende a condizir este processo abordando a classe gramatical que deve ser evolu\'{i}da. Neste caso analisador que muitas vezes realizaria o trabalho por tentativa e erro, tem como base a gram\'{a}tica do c\'{o}digo a ser analisado. Especifica\c{c}\~{o}es do analisador s\~{a}o derivados automaticamente da semi gram\'{a}tica. Diferentes tecnologias de an\'{a}lise que podem ser orientadas em oposi\c{c}\~{a}o a uma tecnologia espec\'{i}fica. Assim o processo de personaliza\c{c}\~{a}o/evolu\c{c}\~{a}o \'{e} suscept\'{i}vel de exigir a entrada de um engenheiro de {\it grammarware} o qual tem conhecimento pr\'{e}vio da gram\'{a}tica a ser analisada.

%Um ponto cr\'{i}tico quanto a an\'{a}lise de c\'{o}digo fonte \'{e} o \textit{parser} da linguagem, onde \'{e} necess\'{a}rio reconhecer uma frase para efetuar a interpreta\c{c}\~{a}o ou fazer a tradu\c{c}\~{a}o para que a cria\c{c}\~{a}o da representa\c{c}\~{a}o intermedi\'{a}ria aconte\c{c}a. Inicialmente \'{e} necess\'{a}rio identificar se a frase que ser\'{a} tratada \'{e} um \textit{assignment} ou uma chamada de fun\c{c}\~{a}o.
 
%Reconhecer uma frase acarreta em duas coisas, distingui-la de outras constru\c{c}\~{o}es e identificar os elementos e as subestruturas que comp\~{o}em esta frase. Por exemplo se uma frase for reconhecida como um \textit{assignment}, pode-se identificar as vari\'{a}veis a esquerda do operador \texttt{=} e uma express\~{a}o que \'{e} a subestrutura a direita. Este ato de reconhecer uma frase \'{e} denominado \textit{Parse}.


%\section{Parse}

%Confome discutido anteriormente, o parser de programas escritos em uma linguagem de program\c c\~{a}o 
%\'{e} um dos componentes necess\'{a}rios para a constru\c c\~{a}o de ferramentas de an\'{a}lise 
%est\'{a}tica. Vale ressaltar que o analisador est\'{a}tico constru\'{i}do neste trabalho reusou uma infraestrutura 
%da plataforma Eclipse~\cite{} que oferece um parser atualizado da linguagem Java. Por outro lado, como 
%se trata de um tipo de componente central para solu\c c\~{o}es baseadas em gram\'{a}tica, esta se\c c\~{a}o 
%revisa brevemente quatro padr\~{o}es adotados para a implementa\c c\~{a}o de parsers~\cite{Parr:2009:LIP:1823613}. S\~{a}o eles: 
%
%{\color{red}Por favor, revisem essa se\c c\~{a}o.}

\section{Representa\c{c}\~{a}o Intermedi\'{a}ria {\color{red}Se\c{c}\~{a}o Revisada -Parser-.}}\label{sec:IR}

Conforme introduzido anteriormente na Figura:~\ref{fig:stagesAnalyzer}, \'{e} gerar uma representa\c{c}\~{a}o intermedi\'{a}ria da linguagem Java. Para efetuar essa tarefa √© necess√°rio antes de tudo reconhecer \texttt{frases} entretanto para criar um reconhecimento de \texttt{frases} faz-se necess√°rio duas etapas. Distinguir as contru\c{c}√µes que compoem a linguagem e identificar os elementos e subestruturas das \texttt{frases}. Terrance Parr em ~\cite{Parr:2009:LIP:1823613}, explica que o ato de reconhecer \texttt{frase} em computa\c{c}\~{a}o √© denominado \textit{parser}.

A estrutura do \textit{parser} \'{e} composta de maneira similar as senten\c{c}as da l\'{\i}ngua portuguesa, identificando verbos, nomes, substantivos, etc... De modo similar \'{e} necess\'{a}rio fazer a mesma identifica\c{c}\~{a}o em um linguagem de programa\c{c}\~{a}o, reconhecendo operadores, vari\'{a}veis e outros s\'{\i}mbolos. E a combina\c{c}\~{a}o dos s\'{i}mbolos \'{e} denominado \texttt{tokens}.

A representa\c{c}\~{a}o do \textit{parser} \'{e} feita atrav\'{e}s de uma √°rvore onde Tokens ficam nas folhas e estas  compoem as frases. \'{E} utilizando uma \'{a}rvore para representar porque com esta \'{e} poss\'{\i}vel extair toda informa\c{c}\~{a}o que seja necess\'{a}ria da linguagem. A Figura:~\ref{fig:treeParse} exibe com mais detalhes o parser sendo representado por uma \'{a}rvore.

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/treeParser}
	\label{fig:treeParse}
	\caption{Representa\c{c}\~{a}o da uma frase.}
\end{figure}


Existem muitos padr\~{o}es de parses pois algumas linguagens s\~{a}o mais complexas que outras. Tendo em visata o desafio que \'{e} trabalhar e analisar uma linguagem de programa\c{c}\~{a}o, alguns padr\~{o}es adotados para este contexto facilitam esta tarefa e com isso este trabalho abordar\'{a} os quatro conceitos  mais importantes segundo Terence Parr em \cite{Parr:2009:LIP:1823613} para prover o parser de acordo com a necessidade.
\begin{itemize}
	\item \textbf{Mapping Grammars to Recursive-Descent Recognizers}\\
	Sua proposta \'{e} traduzir uma gram\'{a}tica para uma recurs\~{a}o descendente para reconhecer frases e senten\c{c}as em uma linguagem especificada por uma gram\'{a}tica. Este padr\~{a}o identifica o n\'{u}cleo do fluxo de controle para qualquer recurs\~{a}o descendente e \'{e} utilizado nos 3 padr\~{o}es seguintes. 
	Para construir um reconhecedor l\'{e}xico ou \textit{parsers} manualmente o melhor ponto de in\'{i}cio \'{e} a gram\'{a}tica, com isso este padr\~{a}o fornece uma maneira simples de construir reconhecedores diretamente de sua gram\'{a}tica.
	
	\item \textbf{LL(1) Recursive-Descent Lexer}\\
	O objetivo deste padr\~{a}o \'{e} para emitir uma sequ√™ncia de s\'{i}mbolos. Cada s\'{i}mbolo tem dois atributos prim\'{a}rios: um tipo de \textit{token}(s\'{i}mbolo da categoria) e o texto associado por exemplo 
	no portugu√™s, temos categorias como verbos e substantivos, bem como s\'{i}mbolos de pontua\c{c}\~{a}o, como v\'{i}rgulas e pontos. Todas as palavras dentro de uma determinada categoria s\~{a}o do mesmo tipo de \textit{token}, embora o texto associado seja diferente. O tipo de nome do \textit{token} representa o categoria identificador. Ent\~{a}o precisamos tipos de \textit{token} para o vocabul\'{a}rio \textit{string} fixa s\'{i}mbolos como tamb\'{e}m lidar com espa\c{c}os em branco e coment\'{a}rios.
	\item \textbf{LL(1) Recursive-Descent Parser}\\
	Esse \'{e} o mais conhecido padr\~{a}o de an\'{a}lise descendente recursiva. Ele s\'{o} precisa	a olhar para o s\'{i}mbolo de entrada atual para tomar decis\~{o}es de an\'{a}lise. Para cada regra de gram\'{a}tica, existe um m\'{e}todo de an\'{a}lise no analisador. Este padr\~{a}o analisa a estrutura sint\'{a}tica da sequ√™ncia sinal de uma frase usando um \'{u}nico \textit{token} \textit{lookahead}. Este analisador pertence √† LL(1) classe do analisador de cima para baixo, em especial, porque usa um \'{u}nico sinal de verifica\c{c}\~{a}o √† frente (da\'{i} o "1" no nome). √â o principal mecanismo de todos os padr\~{o}es de an\'{a}lise subsequentes. Este padr\~{a}o mostra como implementar as decis\~{o}es de an\'{a}lise que utilizam um s\'{i}mbolo \'{u}nico da vis\~{a}o antecipada. √â a forma mais fraca de descendente recursivo parser, mas o mais f\'{a}cil de compreender e aplicar.
	\item \textbf{LL(k) Recursive-Descent Parser}\\
	Este padr\~{a}o utiliza a o modo \textit{top-down} para percorrer um \'{a}rvore sem\^{a}ntica com o aux\'{i}lio de express\~{o}es booleanas que ajudam na tomada de decis\~{a}o e estas express\~{o}es s\~{a}o conhecidas como predicados sem\^{a}nticos.
\end{itemize}


O principal motivo da representa\c{c}\~{a}o intermedi\'{a}ria ser uma \'{a}rvore \'{e} por possuir uma estrutura regular e com os n\'{o}s preservam a hierarquia, devido essa regularidade \'{e} poss\'{i}vel automatizar esta tarefa utilizando ferramentas como no caso deste trabalho a biblioteca Eclipse JDT a qual possui classes especializadas em gerar e analisar as representa\c{c}\~{o}es intermedi\'{a}rias dos c\'{o}digo fonte da linguagem Java.




\section{Refactoring}\label{sec:refactoring}

Por defini\c{c}\~{a}o o refactoring \'{e} mudan\c{c}a interna do software sem alterar seu comportamento tornando assim seu entendimento mais claro. Visando evitar que sejam perdidas diversa horas para identificar poss\'{\i}veis oportunidades de classes onde possam ser evolu\'{\i}das, este trabalho de conclus\~{a}o identifica trechos de c\'{o}digo dentro das classes que pode ser evolu\'{i}dos.

Muitas modifica\c{c}\~{o}es podem ser feitas em um software mas segundo M.Fowler at al~\cite{martinFowlerRafactoring} somente \'{e} considerado refactoring mudan\c{c}as que facilitam o entendimento do software. Contrastando esta vis\~{a}o existem mudan\c{c}as com objetivo de melhorar o desempenho do software onde somente s\~{a}o alterada as estruturas internas permanecendo inalterado o comportamento do software. Entretanto a melhoria na performance do software geralmente eleva o grau de dificuldade para sua compreens\~{a}o, o que faz com que algumas dessas evolu\c{c}es\~{o} visando desempenho n\~{a}o sejam caracterizadas como refactoring dado a defini\c{c}\~{a}o.

Dentre refatorar para facilitar o entendimento, para tornar o programa mais r\'{a}pido, para encontrar bugs e para melhorar/atualizar o design, motivos apresentados por M.Fowler at. al.~\cite{martinFowlerRafactoring}, este trabalho concentrou-se no \'{u}ltimo motivo para identificar poss\'{\i}veis casos onde o design do software pode ser evolu\'{\i}do por substituir funcionalidades de vers\~{o}es anteriores da linguagem Java.

Um software que n\~{a}o \'{e} refatorado tem o seu desgin deteriorado, o que leva a dificultar o entendimento do c\'{o}digo. Um design ultrapassado tem mais c\'{o}digo que o necess\'{a}rio para realizar a mesma tarefa. O que leva a um aspecto crucial para a melhoria, que \'{e} c√≥digo duplicado. Vale ressaltar que reduzir a quantidade de c\'{o}digo n\'{a}o impl\'{i}ca necessariamente na melhora do desempenho do software mas sim em ter um design mais atual.

O Listing:~\ref{lst:fp}, exemplifica de forma emp\'{i}rica um {\it filter} em um {\it collection} onde ocorre uma redu\c{c}\~{a}o significativa de c\'{o}digo al\'{e}m de um design mais atual por utilizar express\~{o}es lambda que foram adicionadas em Java 8. Vale destacandar que o Listing:~\ref{lst:fp} continua com mesmo comportamento ap√≥s o refactoring, desta forma nenhum usu√°rio ou desenvolvedor pode alegar que o software foi modificado.


\begin{lstlisting}[caption={The \textsc{Exmplo de Filter Pattern}}\label{lst:fp},language=Java] 
//...
for(T e: collection) {
   if(e.pred(args)) {
      otherCollection.add(e);
   }
}

//might be replaced by:
collection.stream().
	filter(e->pred(args).
		forEach(e -> otherCollection.add(e));
\end{lstlisting}


Conforme explica M.Fowler at. al.~\cite{martinFowlerRafactoring} algumas vezes n\~{a}o se deve ser refatorar o c\'{o}digo. Um desses casos \'{e} quando existir a necessidade de reescrever todo o c\'{o}digo, um outro caso \'{e} a necessidade de manter um  c\'{o}digo de f\'{a}cil entendimento para os programadores iniciantes. O que \'{e} uma decis\~{a}o dif\'{i}cil, no caso do Listing:~\ref{lst:fp} \'{e} poss\'{\i}vel fazer uma evolu\c{c}\~{a}o com a parte funcional de Java 8 entretanto alguns desenvolvedores podem n\~{a}o possuir  conhecimento adequado da parte funcional e com isso \'{e} recomendado que n\~{a}o seja evolu\'{\i}do o c\'{o}digo.


Tendo em vista que aplicar um \textit{refactoring} demanda tempo isto torna uma tarefa custosa para empresas, este fator \'{e} determinante para que programadores n\~{a}o refatorem seu c\'{o}digos em muitos casos. Com esse cen\'{a}rio \'{e} imprecind\'{i}vel o uso de ferramentas refatorem ou auxiliem nesta tarefa. Auxiliando nesta tarefa este trabalho identifica possibilidades de refatora\c{c}\~{a}o, ao utilizarem estas ferramentas torna mais acess√≠vel ao programador e a emrpesa refatorar pois o trabalho √© direcionado fazendo com que tempo seja poupado.



\section{An√°lise est√°tica}\label{sec:as}

Em computa\c{c}\~{a}o an\'{a}lise est\'{a}tica \'{e} a refer\^{e}ncia a qualquer processamento realizado em c\'{o}digo fonte sem a necessidade de execut\'{a}-lo, com isto a an\'{a}lise est\'{a}tica torna-se uma poderosa t\'{e}cnica por permitir r\'{a}pidas considera\c{c}\~{o}es por possibilitar uma larga explora\c{c}\~{a}o em um projeto podendo evitar erros triviais e simular alguns cen\~{a}rios para tal an\'{a}lise sem a necessidade do projeto ser executado.

Ferramentas que auxiliem a an\'{a}lise est\'{a}tica tem grande chance de ser um poderoso aux\'{i}lio no desenvolvimento do software tendo em vista que pode reduzir a quantidade de erros e diminuir a quantidade de \texttt{refactoring} o qual tem um custo elevado para os projetos de software.

\'{E} nesse contexto que este trabalho faz sua contribui\c{c}\~{a}o por utilizar a an\'{a}lise est\'{a}tica para verificar n\~{a}o possibilidade de falhas ou \textit{bad smell}, mas sim de identificar chances reais de evoluir para \'{u}ltimas \textit{features} da linguagem Java sem interferir no comportamento interno do programa conforme preconiza M.Fowler at. al.~\cite{martinFowlerRafactoring}.

A linguagem Java proporciana duas maneiras de realizar an\'{a}lise est\'{a}tica, a primeira \'{e} atrav√©s c\'{o}digo fonte, \textit{.java} e a segunda atrav\'{e}s do \textit{bytecode}, \textit{.class}. Este trabalho foca em realizar an\'{a}lise no c\'{o}digo fonte, entre tanto nada impede que o trabalho seja realizado da segunda maneira. Existem programas renomados que realizam tal an\'{a}lise utilizando os \textit{bytecodes} e um destes programas \'{e} o FindBugs~\cite{FindBugs}.

%An√°lise est√°tica √© uma t√©cnica autom√°tica no processo de verifica\c{c}√£o de software realizado por algumas ferramentas sem a necessidade de que o software tenha sido executado. Para Java exitem duas possibilidades de realizar tal an√°lise na qual uma das t√©cnicas realiza a primeira \'{e} aan√°lise no c√≥digo fonte e a outra a realiza no {\it bytecode} do programa segundo N. Ayewah at. al. ~\cite{Ayewah:2008:USA:1439186.1439221}. Neste trabalho ser utilizada a pesquisa baseada no c√≥digo fonte sem que tenha sido executado devido a flexibilidade e infraestrutura consolidada encontrada no Eclipse AST.

Para obter sucesso atrav\'{e}s nas an\'{a}lises realizadas, \'{e} necess\'{a}rio determinar padr\~{o}es para encontrar caracter\'{i}sticas que dejesam ser evolu\'{i}das para a \'{u}ltima vers\~{a}o da linguagem Java. Estes padr\~{o}es s\~{a}o estabelecidos em uma estrutura que seja capaz de pesquisar nos n\'{o}s da \'{a}rvore da representa\c{c}\~{a}o intermedi\'{a}ria para extrair as informa\c{c}\~{o}es pertinentes.

%Um fato importante √© que tal an√°lise somente obt\'{e}m sucesso se forem determinados padr\~{o}es ou comportamento para que sejam pesquisados no software. Neste projeto o tais comportamentos s√£o determinados por {\it visitors} conforme explica Gamma et. al. ~\cite{Gamma:1995} devido a toda infraestrutura a qual as ferramentas do eclipse fornecem facilidade para que seja realizada uma an√°lise baseada em padr√µes.

A t\'{e}cnica utilizada para pesquisar nos n\'{o}s das \'{a}rvores foi utilizar o padr\~{a}o de projeto \textit{Visitor} proposto por  Gamma et. al.~\cite{Gamma:1995}, pois este possibilitar que seja realizada uma opera\c{c}\~{a}o sobre todos os elementos de uma estrutura,  neste caso a opera\c{c}\~{a}o  \'{e} a pesquisa e a estrutura a representa\c{c}\~{a}o intermedi\'{a}ria.


A verifica\c{c}\~{a}o de software possibilita a detec\c{c}\~{a}o de falhas de maneira precoce durante as fases de desenvolvimento entretanto este n\~{a}o \'{e} o objetivo deste trabalho pois existem ferramentas consolidadas que realizam tal an\'{a}lise de maneira excepcional. Aqui o objetivo principal \'{e} alertar ao desenvolvedor a possibilidade de usar o que h\'{a} de mais recente na linguagem Java.

%Devido a este trabalho de verifica\c{c}√£o de software √© poss√≠vel detectar falhas de forma precoce nas fases de  desenvolvimento evitando que bugs e falhas sejam introduzidas e at√© mesmo postergados e isso √© uma vantagem existe a economia de tempo com falhas simples, {\it  feedback} r√°pido para alertar a equipe devido as falhas ocorridas e pode-se ir al√©m de simples casos de testes podendo aprimorar estes para que  fiquem mais rigorosos pois a partir do momento que o analisador encontrar uma falha √© poss√≠vel criar um teste de caso para que esta seja testada aumentando a confiabilidade do software.

%Existe limita\c{c}\~{a}o quanto a capacidade dos analisadores est\'{a}ticos como em \textit{software} desenvolvidos sem qualquer uso de padr√µes ou sem arquiteturas consolidadas, criado por equipes composta de desenvolvedores inexperientes o qual a ferramente poder√° apontar erros que s√£o falsos positivos que s√£o erros detectados que n√£o existem pois o analisador pesquisa por padr√µes e estruturas consolidadas. Tais problemas s√£o desagrad√°veis por√©m n√£o oferecem riscos ao desenvolvimento, podem afetar outras √°reas como a de {\it refactoring} a qual poder√° encontrar dificuldade em melhorar um c√≥digo que n√£o segue padr√£o. Vale ainda ressaltar que a penalidade de encontrar um falso positivo √© a perda de tempo em fazer uma inspe\c{c}√£o no c√≥digo para comprovar se √© ou n√£o uma falha. Tamb√©m h√° a possibilidade de falsos negativos o que cabe ao programador verificar para evitar que tais limita√ß√£o do analisador n√£o se propague durante o ciclo de desenvolvimento.


%A capacidade dos analisadores est\'{a}ticos 


%\input{capitulos/AnaliseLexica}%\input{capitulos/AnaliseLexica}