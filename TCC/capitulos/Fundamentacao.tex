%\input{capitulos/HistoriaDaLinguagem}
%\input{capitulos/AspectosEvolutivos}
\chapter{Fundamentaç\~{a}o}

Conforme mencionado no cap\'{i}tulo anterior, o principal objetivo deste trabalho de conclus\~{a}o de curso \'{e} 
identificar oportunidades de evoluç\~{a}o de c\'{o}digo em projetos que utilizam recursos anteriores a Java 7 e Java 8, 
algo necess\'{a}rio para o contexto de reestrutura\c c\~{a}o de c\'{o}digo que visa adequar um c\'{o}digo 
existente para usar constru\c c\~{o}es mais atuais de uma determinada de linguagem de programa\c c\~{a}o 
(no caso, a linguagem Java). Importante destacar que as vers\~{o}es da linguagem Java mencionadas anteriormente
introduziram novos recursos, tais como: \texttt{multi-catch}, \texttt{try-with-resourse}, \texttt{switch-string} 
e \texttt{lambda expressions}; e que esse tipo de evoluç\~{a}o constitui uma nova perspectiva de \textit{refactoring}, que se caracteriza 
por uma transforma\c c\~{a}o de c\'{o}digo que preserva comportamento e que passa a usar  
novas constru\c c\~{o}es da linguagem de programa\c c\~{a}o (conforme defendido por Overbey and Johnson~\cite{Overbey:2009}). 

Para atingir o objetivo do trabalho de conclus\~{a}o de curso, foi necess\'{a}rio estudar temas relacionados 
\`{a} evolu\c c\~{a}o da linguagem Java, engenharia de linguagens de software (ou no Ingl\^{e}s Software 
Language Engineering) e refatoramento de c\'{o}digo (\emph{code refactoring}).  Para dar mais clareza ao leitor 
sobre essas tem\'{a}ticas, esse cap\'{i}tulo apresenta uma vis\~{a}o geral sobre esses temas. Note que n\~{a}o foi objetivo
deste trabalho implementar um mecanismo de transforma\c c\~{a}o de c\'{o}digo, mas sim construir um suporte ferramental 
efetivo para compreender como os desenvolvedores usam as constru\c c\~{o}es existentes na linguagem Java e {\bf identificar 
oportunidades de melhoria de c\'{o}digo}, algo essencial para permitir a atualiza\c c\~{a}o de um c\'{o}digo existente 
que usa constru\c c\~{o}es ultrapassadas de uma linguagem de programa\c c\~{a}o. 
 
 
 
\section{Evoluç\~{a}o Linguagem Java}\label{sec:evolucaoJava}

No começo da d\'{e}cada de 90 um pequeno grupo de engenheiros da SUN Microsystems chamados de "\textit{Green Team}" acreditava que a pr\'{o}xima grande \'{a}rea da computaç\~{a}o seria a uni\~{a}o de equipamentos eletroeletrônicos com os computadores. O "\textit{Green Team}" liderado por James Gosling, demonstrou a linguagem de programaç\~{a}o Java, que foi desenvolvida pela equipe e originalmente era chamada de Oak, foi desenvolvida para dispositivos de entretenimento como aparelhos de TV a cabo, por\'{e}m n\~{a}o foi bem aceita no meio. Em 1995 com a massificaç\~{a}o da Internet, a linguagem Java teve sua primeira grande aplicaç\~{a}o o navegador Netscape.

Java \'{e} uma linguagem de programaç\~{a}o de prop\'{o}sito geral orientada a objetos, concebida especificadamente para ter poucas dependências de implementaç\~{a}o o que acarreta que uma vez que a aplicaç\~{a}o foi desenvolvida ela poder\'{a} ser executada em qualquer ambiente computacional.

Na sua primeira vers\~{a}o chamada de Java 1 (\acs{JDK} 1.0.2) haviam oito pacotes b\'{a}sicos do java como: \texttt{java.lang}, \texttt{java.io}, \texttt{java.util}, \texttt{java.net}, \texttt{java.awt}, \texttt{java.awt.image}, \texttt{java.awt.peer} e \texttt{java.applet}. Com isso passou a ser a adotada para o desenvolvimento de ferramentas populares na \'{e}poca como o Netscape 3.0 e o Internet Explorer 3.0.

Sua segunda vers\~{a}o foi o \acs{JDK}1.1 \cite{JDK1.1} que trouxe ganhos em funcionalidades, desempenho e qualidade. Novas aplicaç\~{o}es tamb\'{e}m surgiram como : JavaBeans, aprimoramento do \acs{AWT}, novas funcionalidades como o \acs{JDBC}, acesso remoto ao objeto \acs{RMI} e suporte ao padr\~{a}o Unicode 2.0.

A terceira vers\~{a}o Java 2 (\acs{JDK} 1.2) ofereceu melhorias significativas no desempenho, um novo modelo de segurança flex\'{i}vel e um conjunto completo de Interface de Programaç\~{a}o de Aplicaç\~{a}o \acs{API}'s. O modelo de "\textit{sandbox}" foi ampliado para dar aos desenvolvedores, usu\'{a}rios e administradores de sistema a opç\~{a}o de especificar e gerenciar um conjunto de pol\'{i}ticas de segurança flex\'{i}vel que gerenciam as aç\~{o}es de uma aplicaç\~{a}o ou \textit{applet} que pode ou n\~{a}o ser executada. Foi introduzido o suporte nativo a \textit{thread} para o ambiente operacional Solaris e tamb\'{e}m a compress\~{a}o de mem\'{o}ria para classes carregadas. Alocaç\~{a}o de mem\'{o}ria com melhor desempenho e aprimoramento da coleta de lixo. Arquitetura de m\'{a}quina virtual conect\'{a}vel para outras m\'{a}quinas virtuais, incluindo a \textit{Java HotSpot VMNew}. \textit{Java Native Interface }\acs{JNI} de convers\~{a}o. O novo conjunto de componentes de projeto, \acs{GUI} (\textit{Swing}). \acs{API} Java 2D que fornece novos recursos gr\'{a}ficos 2D e \acs{AWT}, bem como suporte para impress\~{a}o. Java \textit{plug-in} para navegadores, fornecendo um tempo de execuç\~{a}o totalmente compat\'{i}vel com a m\'{a}quina virtual Java amplamente implantadas em navegadores. A inclus\~{a}o do \acs{JDBC} que fornece um acesso mais f\'{a}cil aos dados para consultas mais flex\'{i}veis, suporte ao SQL3 e trouxe melhor desempenho e estabilidade promovidos por cursores de rolagem.


Em 8 de Maio de 2000 foi anunciado o Java 2 vers\~{a}o 1.3 que trouxe ganho de desempenho em relaç\~{a}o a primeira vers\~{a}o da JS2E de cerca de 40\%  no tempo de {\it  start-up}. O {\it Java HotSpot VM} cliente e suas bibliotecas atentando ao desempenho ao fazer o J2SE vers\~{a}o 1.3 a {\it release} o mais r\'{a}pido at\'{e} à data. Novos recursos, como o {\it caching applet} e instalaç\~{a}o do pacote opcional Java atrav\'{e}s da tecnologia Java {\it  Plug-in} para aumentar a velocidade e a flexibilidade com que os {\it applets} e aplicativos baseados na tecnologia Java podem ser implantados. Java {\it  Plug-in} tecnologia \'{e} um componente do ambiente de execuç\~{a}o Java 2 que permite Java {\it applets} e aplicativos executarem. O novo suporte para \acs{RSA}, assinatura eletrônica, com um gerenciamento mais confi\'{a}vel e din\^{a}mico, certificados X.509, e verificaç\~{a}o de arquivos o que significa aumento das possibilidades que os desenvolvedores tem para proteger dados eletrônicos. Uma s\'{e}rie de novos recursos e ferramentas de desenvolvimento da tecnologia J2SE vers\~{a}o 1.3 que permite o desenvolvimento mais f\'{a}cil e r\'{a}pido de aplicaç\~{o}es baseadas na tecnologia {\it web} ou Java {\it  standalone} de alto desempenho. A adiç\~{a}o de RMI/IIOP e o JNDI para a vers\~{a}o 1.3, melhora na interoperabilidade J2SE. Melhora da conectividade com sistemas de {\it  back-end} que suportam CORBA. O novo suporte que o JNDI fornece acesso aos diret\'{o}rios que suportam o populares LDAP Lightweight Directory Access Protocol, entre outros.


No ano de 2002 no dia 6 de Fevereiro, foi lançado a J2SE vers\~{a}o 1.4. Com a vers\~{a}o 1.4, as empresas puderam usar a tecnologia Java para desenvolver aplicativos de neg\'{o}cios mais exigentes e com menos esforço e em menos tempo. As novas funcionalidades como a nova I/O e suporte a 64 bits. A J2SE se tornou plataforma ideal para a mineraç\~{a}o em grande escala de dados, inteligência de neg\'{o}cios, engenharia e cient\'{i}ficos. A vers\~{a}o 1.4 forneceu suporte aprimorado para tecnologias padr\~{o}es da ind\'{u}stria, tais como SSL, LDAP e CORBA a fim de garantir a operacionalidade em plataformas heterogêneas, sistemas e ambientes. Com o apoio embutido para XML, a autenticaç\~{a}o avançada, e um conjunto completo de serviços de segurança, est\'{a} vers\~{a}o forneceu base para padr\~{o}es de aplicaç\~{o}es Web e serviços interoper\'{a}veis. O J2SE avançou para o desenvolvimento de aplicativos de cliente com novos controles de GUI, acelerou Java 2D, a performance gr\'{a}fica, internacionalizaç\~{a}o e localizaç\~{a}o expandida de apoio, novas opç\~{o}es de implantaç\~{a}o e suporte expandido para o at\'{e} ent\~{a}o {\it Windows XP}.

Com a chegada da \acs{JSE2} vers\~{a}o 1.5 (Java 5.0) em 30 de Setembro de 2004, impulsionou benef\'{i}cios extensivos para desenvolvedores, incluindo a facilidade de uso, desempenho global e escalabilidade, monitoramento do sistema e gest\~{a}o e desenvolvimento. O Java 5 foi derivado do trabalho de 15 componentes Java Specification Requests (JSRs) englobando recursos avançados para a linguagem e plataforma. Os l\'{i}deres da ind\'{u}stria na \'{e}poca que participam no grupo de peritos J2SE 5.0 incluiram: Apache Software Foundation, Apple Computer, BEA Systems, Borland Software Corporation, Cisco Systems, Fujitsu Limited, HP, IBM, Macromedia, Nokia Corporation, Oracle, SAP AG, SAS Institute, SavaJe Technologies e Sun Microsystems.

Houve novas funcionalidades foram implementadas como: facilidade de desenvolvimento onde os programadores da linguagem Java pode ser mais eficiente e produtivos com os recursos de linguagem Java 5 que permitiram a codificaç\~{a}o mais segura. Nesta vers\~{a}o surgiu o {\it Generics} ~\cite{OracleGenerics, bracha1998gj}, tipos enumerados, metadados e autoboxing de tipos primitivos permitindo assim uma f\'{a}cil e r\'{a}pida codificaç\~{a}o. Monitoramento e gest\~{a}o permitindo um foco para a nova vers\~{a}o da plataforma, a aplicativos baseados na tecnologia Java {\it Virtual Machine} que passou a ser monitorado e gerenciado com o {\it built-in} de suporte para Java {\it Management Extensions}. Suporte para sistemas de gest\~{a}o empresarial baseados em SNMP tamb\'{e}m \'{e} vi\'{a}vel. Um olhar novo sobre aplicativos baseado na tecnologia Java padr\~{a}o e proporcionou um melhor desenvolvimento GUI para aplicativos baseados na tecnologia Java. A J2SE 5.0 teve suporte completo a internacionalizaç\~{a}o e tamb\'{e}m inseriu suporte para aceleraç\~{a}o de hardware por meio da {\it API OpenGL } e tamb\'{e}m para o sistema operacional Solaris e sistemas operacionais da distribuiç\~{a}o Linux. **Maior desempenho e escalabilidade com a nova vers\~{a}o que incluiu melhorias de desempenho, reduç\~{a}o no tempo de inicializaç\~{a}o, um menor consumo de mem\'{o}ria e JVM auto ajust\'{a}vel para gerar maior desempenho geral do aplicativo e desenvolvimento em J2SE 5.0 em relaç\~{a}o a vers\~{o}es anteriores.

Java 1.6 (Java 6) foi divulgado em 11 de dezembro de 2006. Tornou o desenvolvimento mais f\'{a}cil, r\'{a}pido e eficiente em termos de custos e ofereceu funcionalidades para serviços web, suporte linguagem din\^{a}mica, diagn\'{o}sticos e aplicaç\~{o}es {\it desktop}. Com a chegada dessa nova vers\~{a}o do Java houve combinaç\~{a}o com o {\it NetBeans} IDE 5.5 fornecendo aos desenvolvedores uma estrutura confi\'{a}vel, de c\'{o}digo aberto e compat\'{i}vel, de alta performance para entregar aplicativos baseados na tecnologia Java mais r\'{a}pido e f\'{a}cil do que nunca. O {\it NetBeans} IDE fornece uma fonte aberta e de alto desempenho, modular, extens\'{i}vel, multiplataforma Java IDE para acelerar o desenvolvimento de aplicaç\~{o}es baseadas em software e serviços {\it web}. O Java 1.6 ajudou a acelerar a inovaç\~{a}o para o desenvolvedor, aplicativos de colaboraç\~{a}o {\it online} e baseadas na {\it web}, incluindo um novo quadro de desenvolvedores \acs{API}'s para permitir a mistura da tecnologia Java com linguagens de tipagem din\^{a}mica, tais como PHP, Python, Ruby e tecnologia JavaScript. A Sun tamb\'{e}m criou uma coleç\~{a}o de mecanismos de {\it script} e pr\'{e}-configurado o motor {\it JavaScript Rhino} na plataforma Java. Al\'{e}m disso, o software inclui uma pilha completa de clientes de serviços web e suporta as mais recentes especificaç\~{o}es de serviços {\it web}, como \acs{JAX-WS} 2.0, \acs{JAXB} 2.0, \acs{STAX} e \acs{JAXP}. A plataforma Java 1.6 forneceu ferramentas expandidas para o diagn\'{o}stico, gest\~{a}o e monitoramento de aplicaç\~{o}es e tamb\'{e}m inclui suporte para o novo {\it NetBeans Profiler} 5.5 para {\it Solaris DTrace } e, uma estrutura de rastreamento din\^{a}mico abrangente que est\'{a} inclu\'{i}do no sistema operacional Solaris 10. Al\'{e}m disso, o software Java SE 6 aumenta ainda mais a facilidade de desenvolvimento com atualizaç\~{o}es de interface ferramenta para o {\it Java Virtual Machine} (\acs{JVM}) e o {\it Java Platform Debugger Architecture} (\acs{ACDP}).

Java 7 ~\cite{JSE7} foi lançado no dia 28 de julho de 2011. Essa vers\~{a}o foi resultado do desenvolvimento de toda a ind\'{u}stria o que envolveu uma revis\~{a}o de c\'{o}digo aberto e extensa colaboraç\~{a}o entre os engenheiros da {\it Oracle} e membros do ecossistema Java em todo o mundo atrav\'{e}s da comunidade {\it OpenJDK} e do {\it Java Community Process} (\acs{JCP}). Compatibilidade com vers\~{o}es anteriores de Java 7 com vers\~{o}es anteriores da plataforma a fim de preservar os conjuntos de habilidades dos desenvolvedores de software Java e proteger os investimentos em tecnologia Java. As alteraç\~{o}es da linguagem ajudaram a aumentar a produtividade do desenvolvedor e simplificar tarefas comuns de programaç\~{a}o, reduzindo a quantidade de c\'{o}digo necess\'{a}rio, esclarecendo sintaxe e tornar o c\'{o}digo com mais legibilidade. Melhor suporte para linguagens din\^{a}micas incluindo: Ruby, Python e JavaScript, resultando em aumentos substanciais de desempenho no \acs{JVM}. Uma nova API {\it multicore ready} que permite aos desenvolvedores para se decompor mais facilmente problemas em tarefas que podem ser executadas em paralelo em n\'{u}meros arbitr\'{a}rios de n\'{u}cleos de processador. Uma interface de I/O abrangente para trabalhar com sistemas de arquivos que podem acessar uma ampla gama de atributos de arquivos e oferecem mais informaç\~{o}es quando ocorrem erros. Novos recursos de rede e de segurança. Suporte expandido para a internacionalizaç\~{a}o, incluindo suporte a Unicode 6.0. Al\'{e}m de vers\~{o}es atualizadas das bibliotecas padr\~{a}o.

Com o lançamento do Java SE 8 em 18 de Março de 2014, permitiu uma maior produtividade e desenvolvimento de aplicativos significativos aumentos de desempenho atrav\'{e}s da reduç\~{a}o de linhas de c\'{o}digo, {\it collectons} melhoradas, modelos mais simples de programaç\~{a}o paralela e uso mais eficiente de processadores {\it multi-core}. As principais caracter\'{i}sticas do \acs{JDK} 8 s\~{a}o o projeto Lambda, {\it Nashorn JavaScript Engine}, um conjunto de perfis compactas e a remoç\~{a}o da "geraç\~{a}o permanente" do {\it HotSpot Java Virtual Machine} (\acs{JVM}). A \acs{JDK} 8 alcançou desempenho recorde mundial para 4 sistemas de soquete em servidores baseados em Intel e NEC por 2 sistemas de soquete em servidores SPARC da Oracle T5, com uma melhoria de desempenho de 12\% para 41\% em comparaç\~{a}o com o JDK 7 na mesma configuraç\~{a}o de Oracle.

%O \acs{JDK} 8 adicionou novas funcionalidades como as express\~{o}es lambda com as seguintes caracter\'{i}sticas: referências a m\'{e}todos s\~{a}o compactas e maior legibilidade express\~{o}es lambda para m\'{e}todos que j\'{a} têm um nome. M\'{e}todos padr\~{a}o que permitem adicionar novas funcionalidades para as interfaces de suas bibliotecas e assegurar a compatibilidade bin\'{a}ria com o c\'{o}digo escrito para vers\~{o}es mais antigas dessas interfaces. Eles m\'{e}todos de interface que têm uma aplicaç\~{a}o e a palavra-chave padr\~{a}o no in\'{i}cio da assinatura do m\'{e}todo. Al\'{e}m disso, pode-se definir m\'{e}todos est\'{a}ticos em interfaces. Novos e aprimorados APIs que se aproveitam de express\~{o}es lambda e dos {\it streams} em Java 8 descrevem as classes novos e aprimorados que se aproveitam de express\~{o}es lambda e {\it streams}. Aprimoramento do compilador Java aproveita digitaç\~{a}o alvo para inferir os par\^{a}metros de tipo de um m\'{e}todo de invocaç\~{a}o gen\'{e}rica. O tipo de destino de uma express\~{a}o \'{e} o tipo de dados que o compilador Java espera, dependendo de onde a express\~{a}o aparece, por exemplo, pode-se usar o tipo de destino de uma instruç\~{a}o de atribuiç\~{a}o para o tipo de inferência em Java 7. No entanto, em Java 8, você pode usar o tipo de destino para a inferência de tipos em mais contextos. Anotaç\~{o}es sobre tipos Java onde \'{e} poss\'{i}vel aplicar uma anotaç\~{a}o em qualquer lugar onde um tipo \'{e} usado, utilizado em um conjunto com um sistema de tipo de conector, isso permite a verificaç\~{a}o de tipo mais forte de seu c\'{o}digo e repetiç\~{a}o de anotaç\~{o}es que agora \'{e} poss\'{i}vel aplicar o mesmo tipo de anotaç\~{a}o mais de uma vez para a mesma declaraç\~{a}o ou o tipo de utilizaç\~{a}o.

	\clearpage



\section{Engenharia dos Softwares de Linguagem}\label{sec:softEng}

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/stagesLanguageApp}
	\label{fig:stagesLanguageApp}
	\caption{Fases de aplicaç\~{o}es com linguagens.}
\end{figure}

A manipulaç\~{a}o de qualquer linguagem de programaç\~{a}o \'{e} uma tarefa desafiadora e complicada de tal forma que o cen\'{a}rio para estes aplicativos podem ser a manipulaç\~{a}o de um \texttt{XML}, automatizar a transformaç\~{a}o dos dados de um banco de dados antigo para um mais atual, efetuar a importaç\~{a}o de usu\'{a}rio de uma antiga vers\~{a}o ou at\'{e} mesmo de um produto concorrente dentre outros softwares que manipulam uma linguagem.

Tendo em vista a complexidade envolvida \'{e} necess\'{a}rio dividir este trabalho de manipulaç\~{a}o de uma linguagem em componentes que quando combinados proporcionam um programa capaz de realizar a tarefa desejada com a linguagem trabalhada. A Figura:~\ref{fig:stagesLanguageApp} exibe as divis\~{o}es ocorridas para trabalha uma linguagem onde fica claro o \textit{pipeline} para a manipulaç\~{a}o da entrada onde cada est\'{a}gio tem como entrada a sa\'{i}da do est\'{a}gio anterior.

Existe um esfor\c{c}o consider\'{a}vel para tratar a engenharia de linguagens de programaç\~{a}o como sendo o desenvolvimento de um software comum. Algumas aplicaç\~{o}es t\'{i}picas deste dom\'{i}nio s\~{a}o \texttt{reconhecedor, interpretador, tradutor, gerador} conforme menciona Terrance Parr em~\cite{Parr:2009:LIP:1823613},  al\'{e}m de \texttt{ferramentas reconhecedoras de bugs}. Uma dessas \'{e} a ferramenta \textit{FindBugs}~\cite{FindBugs} que faz uso de alguns est\'{a}gios descritos por Terance Parr em ~\cite{Parr:2009:LIP:1823613} para encontrar poss\'{i}veis falhas em um programa que utilize a linguagem Java.

A combinaç\~{a}o de algumas das ferramentas citadas anteriormente, originou o \textit{FindBugs}~\cite{FindBugs} que \'{e} uma ferramenta desenvolvida em Java que processa o \texttt{bytecode} para identificar padr\~{o}es de erros. A Figura:~\ref{fig:findBugs} demonstra no mais alto n\'{i}vel a junç\~{a}o das ferramentas que o comp\~{o}e. 

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/pipelineFindbugs}
	\label{fig:findBugs}
	\caption{Fase do pipiline do FindBugs.}
\end{figure}

\texttt{Reconhecedor:} É uma construç\~{a}o capaz de receber uma estrutura de dado como um input ou um fluxo de inputs. O fluxo de input pode geralmente \'{e} texto puro mas pode ser utilizado dado bin\'{a}rio. Como exemplo de aplicaç\~{a}o tem-se ferramentas analisadoras de referências cruzadas, e ferramentas para carregar classes.

\texttt{Interpretador:} Um interpretador, lê uma entrada, decodifica e executa as instruç\~{o}es, interpretadores variam de simples calculadoras at\'{e} a implementaç\~{a}o de linguagens de programaç\~{a}o como Java, Python e PHP.

\texttt{Tradutor:}A partir um input de texto ou bin\'{a}rio \'{e} emitido uma sa\'{i}da para uma linguagem que pode ser a mesma ou n\~{a}o. É a combinaç\~{a}o do \textit{reader} e \textit{generator}. Como exemplo tem-se tradutores de linguagens extintas para linguagens atuais, \texttt{refactorers},  gerador de logs e macro pre-processadores.
	
\texttt{Gerador:} Percorre uma estrutura de dado e emite uma sa\'{i}da. Como exemplo tem-se ferramentas de mapeamento de objetos relacionais em banco de dados, serializador de objetos, gerador de c\'{o}digo fonte e geradores de p\'{a}gina web.


\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/stagesAnalizer}
	\label{fig:stagesAnalyzer}
	\caption{Ferramentas necess\'{a}rias para construç\~{a}o do analisador est\'{a}tico.}
\end{figure}

Especificamente no caso deste trabalho \'{e} necess\'{a}rio a construç\~{a}o de um software que realiza an\'{a}lise est\'{a}tica de c\'{o}digo para identificar o uso e oportunidades do uso construç\~{o}es da linguagem Java. E para isso a Figura:~\ref{fig:stagesAnalyzer} exemplifica no alto n\'{i}vel as ferramentas que comp\~{o}em o analisador.



Pode-se compreender este analisador como um {\it grammarware} pois \'{e} um software que depende de gram\'{a}tica para seu funcionamento neste caso a gram\'{a}tica da linguagem Java, pois estes softwares possuem conhecimentos essenciais da  gram\'{a}tica que manipulam. Como exemplos de arquiteturas que possuem tal conhecimento tem-se os programas de convers\~{a}o de dados, processadores de \texttt{XML} e os que efetuam \textit{parses}.

Paul Klint at.al.~\cite{klint2005toward} vai mais al\'{e}m para caracterizar um {\it grammarware} como sendo um software comum, afirmando que este deve  adotar t\'{e}cnicas contempor\^{a}neas a engenharia de software tendo em vista que tais t\'{e}cnicas s\~{a}o utilizadas diariamente no desenvolvimento n\~{a}o sendo nenhuma novidade.

Gram\'{a}ticas e software dependentes de gram\'{a}tica n\~{a}o s\~{a}o inven\c{c}\~{o}es recentes e este conceito faz-se presente em \'{a}reas da computa\c{c}\~{a}o como engenharia reversa, desnvolvimento orientado a aspectos, tranforma\c{c}\~{o}es de programas e metamodelagem.

Alguns cen\'{a}rios favorecem o desenvolvimento de softwares {\it grammarware}, onde dentre os diversos cen\'{a}rios pode-se destacar uma aplicaç\~{a}o que necessite importar perfis de usu\'{a}rios para promover a transi\c{c}\~{a}o da vers\~{a}o antiga para uma vers\~{a}o atual. Esta transi\c{c}\~{a}o deve ser robusta e provavelmente necessitar\'{a} de adpta\c{c}\~{a}o o que em muitos casos necessita de um \textit{parser} para partes que necessitam ser adaptadas.

Um outro cen\'{a}rio real \'{e} desenvolvimento de aplica\c{c}\~{o}es de banco de dados onde \'{e} necess\'{a}rio adotar uma nova linguagem de defini\c{c}\~{a}o para um ambiente espec\'{i}fico. De forma que automatizar esta solu\c{c}\~{a}o requer o uso de um \textit{parser} o qual ser\'{a} respons\'{a}vel por identificar os inputs de entrada para efetuar o mapeamento correto para a sa\'{i}da desejada no formato mais atual.

Outro tipo de \textit{software} que manipula a gram\'{a}tica de uma linguagem,s\~{a}o os que realizam \textit{refactoring}. Dentre diversas caracter\'{i}sitas explicadas por Martin Fowler at.al.~\cite{martinFowlerRafactoring}, fica claro que este trabalho contribui com o intu\'{\i}to de identificar constru\c{c}\~{o}es obsoletas e oportunidades para alguma evolu\c{c}\~{a}o e n\~{a}o efetuando \textit{refactoring} de modo autom\'{a}tico mas sim sugerindo ao desenvolvedor escolher pela evolu\c{c}\~{a}o ou n\~{a}o.

A evolu\c{c}\~{a}o do c\'{o}digo para um mais atual \'{e} mais que procurar por \textit{bad smell} onde s\~{a}o ocorr\^{e}ncias pontuais j\'{a} estabelecidas. A oportunidade de evoluir para uma vers\~{a}o mais atual \'{e} muito mais complexa que meramente melhorar o desgin do \textit{software} e por isso essa sugest\~{a}o deve ser apreciada pelo desenvolvedor com cuidado pois pode ser um quest\~{a}o mais profunda. %depender de SO, versao de compilador etc.

Mesmo sem a implementa\c{c}\~{a}o de \textit{refactoring} uma contribui\c{c}\~{a}o que este trabalho faz \'{e} a identifi\c{c}\~{a}o a capacidade de encontrar c\'{o}digo duplicado como por exemplo ao identificar \texttt{catch} repetidos, ou at\'{e} mesmo melhorar o desempenho com no caso da da utilizaç\~{a}o do \texttt{switch-string} ao inv\'{e}s do \texttt{if-string} pois oracle afirma que o desempenho \'{e} melhor de a implementa\c{c}\~{a}o otimizada do \texttt{switch-string} na documenta\c{c}\~{a}o~\cite{docSwitch}.




%Atualmente a evoluç\~{a}o de uma linguagem de programaç\~{a}o ocorre predominantemente de forma {\it ad-hoc} e em muitos casos manualmente, para a traduç\~{a}o de aplicativos legados, conforme a demanda. A ferramentas de an\'{a}lise para gerar a evoluç\~{a}o necess\'{a}ria, {\it grammarware}, tende a condizir este processo abordando a classe gramatical que deve ser evolu\'{i}da. Neste caso analisador que muitas vezes realizaria o trabalho por tentativa e erro, tem como base a gram\'{a}tica do c\'{o}digo a ser analisado. Especificaç\~{o}es do analisador s\~{a}o derivados automaticamente da semi gram\'{a}tica. Diferentes tecnologias de an\'{a}lise que podem ser orientadas em oposiç\~{a}o a uma tecnologia espec\'{i}fica. Assim o processo de personalizaç\~{a}o/evoluç\~{a}o \'{e} suscept\'{i}vel de exigir a entrada de um engenheiro de {\it grammarware} o qual tem conhecimento pr\'{e}vio da gram\'{a}tica a ser analisada.

%Um ponto cr\'{i}tico quanto a an\'{a}lise de c\'{o}digo fonte \'{e} o \textit{parser} da linguagem, onde \'{e} necess\'{a}rio reconhecer uma frase para efetuar a interpretaç\~{a}o ou fazer a traduç\~{a}o para que a criaç\~{a}o da representaç\~{a}o intermedi\'{a}ria aconteça. Inicialmente \'{e} necess\'{a}rio identificar se a frase que ser\'{a} tratada \'{e} um \textit{assignment} ou uma chamada de funç\~{a}o.
 
%Reconhecer uma frase acarreta em duas coisas, distingui-la de outras construç\~{o}es e identificar os elementos e as subestruturas que comp\~{o}em esta frase. Por exemplo se uma frase for reconhecida como um \textit{assignment}, pode-se identificar as vari\'{a}veis a esquerda do operador \texttt{=} e uma express\~{a}o que \'{e} a subestrutura a direita. Este ato de reconhecer uma frase \'{e} denominado \textit{Parse}.

\section{Representa\c{c}\~{a}o Intermedi\'{a}ria}\label{sec:IR}

Conforme introduzido anteriormente na Figura:~\ref{fig:stagesAnalyzer}, \'{e} gerar uma representa\c{c}\~{a}o intermedi\'{a}ria da linguagem Java. Para efetuar essa tarefa é necessário antes de tudo reconhecer \texttt{frases} entretanto para criar um reconhecimento de \texttt{frases} faz-se necessário duas etapas. Distinguir as contruções que compoem a linguagem e identificar os elementos e subestruturas das \texttt{frases}. Terrance Parr em ~\cite{Parr:2009:LIP:1823613}, explica que o ato de reconhecer \texttt{frase} em computa\c{c}\~{a}o é denominado \textit{parser}.

A estrutura do \textit{parser} \'{e} composta de maneira similar as senten\c{c}as da l\'{\i}ngua portuguesa, identificando verbos, nomes, substantivos, etc... De modo similar \'{e} necess\'{a}rio fazer a mesma identifica\c{c}\~{a}o em um linguagem de programa\c{c}\~{a}o, reconhecendo operadores, vari\'{a}veis e outros s\'{\i}mbolos. E a combina\c{c}\~{a}o dos s\'{i}mbolos \'{e} denominado \texttt{tokens}.

A representa\c{c}\~{a}o do \textit{parser} \'{e} feita atrav\'{e}s de uma árvore onde Tokens ficam nas folhas e estas  compoem as frases. \'{E} utilizando uma \'{a}rvore para representar porque com esta \'{e} poss\'{\i}vel extair toda informa\c{c}\~{a}o que seja necess\'{a}ria da linguagem. A Figura:~\ref{fig:treeParse} exibe com mais detalhes o parser sendo representado por uma \'{a}rvore.

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/treeParser}
	\label{fig:treeParse}
	\caption{Representa\c{c}\~{a}o da uma frase.}
\end{figure}


Existem muitos padr\~{o}es de parses pois algumas linguagens s\~{a}o mais complexas que outras. Tendo em visata o desafio que \'{e} trabalhar e analisar uma linguagem de programa\c{c}\~{a}o, alguns padr\~{o}es adotados para este contexto facilitam esta tarefa e com isso este trabalho abordar\'{a} os quatro conceitos  mais importantes segundo Terence Parr em \cite{Parr:2009:LIP:1823613} para prover o parser de acordo com a necessidade.
\begin{itemize}
	\item \textbf{Mapping Grammars to Recursive-Descent Recognizers}\\
	Sua proposta \'{e} traduzir uma gram\'{a}tica para uma recurs\~{a}o descendente para reconhecer frases e sentenças em uma linguagem especificada por uma gram\'{a}tica. Este padr\~{a}o identifica o n\'{u}cleo do fluxo de controle para qualquer recurs\~{a}o descendente e \'{e} utilizado nos 3 padr\~{o}es seguintes. 
	Para construir um reconhecedor l\'{e}xico ou \textit{parsers} manualmente o melhor ponto de in\'{i}cio \'{e} a gram\'{a}tica, com isso este padr\~{a}o fornece uma maneira simples de construir reconhecedores diretamente de sua gram\'{a}tica.
	
	\item \textbf{LL(1) Recursive-Descent Lexer}\\
	O objetivo deste padr\~{a}o \'{e} para emitir uma sequência de s\'{i}mbolos. Cada s\'{i}mbolo tem dois atributos prim\'{a}rios: um tipo de \textit{token}(s\'{i}mbolo da categoria) e o texto associado por exemplo 
	no português, temos categorias como verbos e substantivos, bem como s\'{i}mbolos de pontuaç\~{a}o, como v\'{i}rgulas e pontos. Todas as palavras dentro de uma determinada categoria s\~{a}o do mesmo tipo de \textit{token}, embora o texto associado seja diferente. O tipo de nome do \textit{token} representa o categoria identificador. Ent\~{a}o precisamos tipos de \textit{token} para o vocabul\'{a}rio \textit{string} fixa s\'{i}mbolos como tamb\'{e}m lidar com espaços em branco e coment\'{a}rios.
	\item \textbf{LL(1) Recursive-Descent Parser}\\
	Esse \'{e} o mais conhecido padr\~{a}o de an\'{a}lise descendente recursiva. Ele s\'{o} precisa	a olhar para o s\'{i}mbolo de entrada atual para tomar decis\~{o}es de an\'{a}lise. Para cada regra de gram\'{a}tica, existe um m\'{e}todo de an\'{a}lise no analisador. Este padr\~{a}o analisa a estrutura sint\'{a}tica da sequência sinal de uma frase usando um \'{u}nico \textit{token} \textit{lookahead}. Este analisador pertence à LL(1) classe do analisador de cima para baixo, em especial, porque usa um \'{u}nico sinal de verificaç\~{a}o à frente (da\'{i} o "1" no nome). É o principal mecanismo de todos os padr\~{o}es de an\'{a}lise subsequentes. Este padr\~{a}o mostra como implementar as decis\~{o}es de an\'{a}lise que utilizam um s\'{i}mbolo \'{u}nico da vis\~{a}o antecipada. É a forma mais fraca de descendente recursivo parser, mas o mais f\'{a}cil de compreender e aplicar.
	\item \textbf{LL(k) Recursive-Descent Parser}\\
	Este padr\~{a}o utiliza a o modo \textit{top-down} para percorrer um \'{a}rvore sem\^{a}ntica com o aux\'{i}lio de express\~{o}es booleanas que ajudam na tomada de decis\~{a}o e estas express\~{o}es s\~{a}o conhecidas como predicados sem\^{a}nticos.
\end{itemize}


O principal motivo da representa\c{c}\~{a}o intermedi\'{a}ria ser uma \'{a}rvore \'{e} por possuir uma estrutura regular e com os n\'{o}s preservam a hierarquia, devido essa regularidade \'{e} poss\'{i}vel automatizar esta tarefa utilizando ferramentas como no caso deste trabalho a biblioteca Eclipse JDT a qual possui classes especializadas em gerar e analisar as representa\c{c}\~{o}es intermedi\'{a}rias dos c\'{o}digo fonte da linguagem Java.





\section{Refactoring}\label{sec:refactoring}

Por defini\c{c}\~{a}o o refactoring \'{e} mudan\c{c}a interna do software sem alterar seu comportamento tornando assim seu entendimento mais claro. Visando evitar que sejam perdidas diversa horas para identificar poss\'{\i}veis oportunidades de classes onde possam ser evolu\'{\i}das, este trabalho de conclus\~{a}o identifica trechos de c\'{o}digo dentro das classes que pode ser evolu\'{i}dos.

Muitas modifica\c{c}\~{o}es podem ser feitas em um software mas segundo M.Fowler at al~\cite{martinFowlerRafactoring} somente \'{e} considerado refactoring mudan\c{c}as que facilitam o entendimento do software. Contrastando esta vis\~{a}o existem mudanças com objetivo de melhorar o desempenho do software onde somente s\~{a}o alterada as estruturas internas permanecendo inalterado o comportamento do software. Entretanto a melhoria na performance do software geralmente eleva o grau de dificuldade para sua compreens\~{a}o, o que faz com que algumas dessas evolu\c{c}es\~{o} visando desempenho n\~{a}o sejam caracterizadas como refactoring dado a defini\c{c}\~{a}o.

Dentre refatorar para facilitar o entendimento, para tornar o programa mais r\'{a}pido, para encontrar bugs e para melhorar/atualizar o design, motivos apresentados por M.Fowler at. al.~\cite{martinFowlerRafactoring}, este trabalho concentrou-se no \'{u}ltimo motivo para identificar poss\'{\i}veis casos onde o design do software pode ser evolu\'{\i}do por substituir funcionalidades de vers\~{o}es anteriores da linguagem Java.

Um software que n\~{a}o \'{e} refatorado tem o seu desgin deteriorado, o que leva a dificultar o entendimento do c\'{o}digo. Um design ultrapassado tem mais c\'{o}digo que o necess\'{a}rio para realizar a mesma tarefa. O que leva a um aspecto crucial para a melhoria, que \'{e} código duplicado. Vale ressaltar que reduzir a quantidade de c\'{o}digo n\'{a}o impl\'{i}ca necessariamente na melhora do desempenho do software mas sim em ter um design mais atual.

O Listing:~\ref{lst:fp}, exemplifica de forma emp\'{i}rica um {\it filter} em um {\it collection} onde ocorre uma redu\c{c}\~{a}o significativa de c\'{o}digo al\'{e}m de um design mais atual por utilizar express\~{o}es lambda que foram adicionadas em Java 8. Vale destacandar que o Listing:~\ref{lst:fp} continua com mesmo comportamento após o refactoring, desta forma nenhum usuário ou desenvolvedor pode alegar que o software foi modificado.


\begin{lstlisting}[caption={The \textsc{Exmplo de Filter Pattern}}\label{lst:fp},language=Java] 
//...
for(T e: collection) {
   if(e.pred(args)) {
      otherCollection.add(e);
   }
}

//might be replaced by:
collection.stream().filter(e->pred(args).forEach(e -> otherCollection.add(e));
\end{lstlisting}


Conforme explica M.Fowler at. al.~\cite{martinFowlerRafactoring} algumas vezes n\~{a}o se deve ser refatorar o c\'{o}digo. Um desses casos \'{e} quando existir a necessidade de reescrever todo o c\'{o}digo, um outro caso \'{e} a necessidade de manter um  c\'{o}digo de f\'{a}cil entendimento para os programadores iniciantes. O que \'{e} uma decis\~{a}o dif\'{i}cil, no caso do Listing:~\ref{lst:fp} \'{e} poss\'{\i}vel fazer uma evolu\c{c}\~{a}o com a parte funcional de Java 8 entretanto alguns desenvolvedores podem n\~{a}o possuir  conhecimento adequado da parte funcional e com isso \'{e} recomendado que n\~{a}o seja evolu\'{\i}do o c\'{o}digo.


Tendo em vista que aplicar um \textit{refactoring} demanda tempo isto torna uma tarefa custosa para empresas, este fator \'{e} determinante para que programadores n\~{a}o refatorem seu c\'{o}digos em muitos casos. Com esse cen\'{a}rio \'{e} imprecind\'{i}vel o uso de ferramentas refatorem ou auxiliem nesta tarefa. Auxiliando nesta tarefa este trabalho identifica possibilidades de refatora\c{c}\~{a}o, ao utilizarem estas ferramentas torna mais acessível ao programador e a emrpesa refatorar pois o trabalho é direcionado fazendo com que tempo seja poupado.



\section{Análise estática}\label{sec:as}

Em computa\c{c}\~{a}o an\'{a}lise est\'{a}tica \'{e} a refer\^{e}ncia a qualquer processamento realizado em c\'{o}digo fonte sem a necessidade de execut\'{a}-lo, com isto a an\'{a}lise est\'{a}tica torna-se uma poderosa t\'{e}cnica por permitir r\'{a}pidas considera\c{c}\~{o}es por possibilitar uma larga explora\c{c}\~{a}o em um projeto podendo evitar erros triviais e simular alguns cen\~{a}rios para tal an\'{a}lise sem a necessidade do projeto ser executado.

Ferramentas que auxiliem a an\'{a}lise est\'{a}tica tem grande chance de ser um poderoso aux\'{i}lio no desenvolvimento do software tendo em vista que pode reduzir a quantidade de erros e diminuir a quantidade de \texttt{refactoring} o qual tem um custo elevado para os projetos de software.

\'{E} nesse contexto que este trabalho faz sua contribui\c{c}\~{a}o por utilizar a an\'{a}lise est\'{a}tica para verificar n\~{a}o possibilidade de falhas ou \textit{bad smell}, mas sim de identificar chances reais de evoluir para \'{u}ltimas \textit{features} da linguagem Java sem interferir no comportamento interno do programa conforme preconiza M.Fowler at. al.~\cite{martinFowlerRafactoring}.

A linguagem Java proporciana duas maneiras de realizar an\'{a}lise est\'{a}tica, a primeira \'{e} através c\'{o}digo fonte, \textit{.java} e a segunda atrav\'{e}s do \textit{bytecode}, \textit{.class}. Este trabalho foca em realizar an\'{a}lise no c\'{o}digo fonte, entre tanto nada impede que o trabalho seja realizado da segunda maneira. Existem programas renomados que realizam tal an\'{a}lise utilizando os \textit{bytecodes} e um destes programas \'{e} o FindBugs~\cite{FindBugs}.

%Análise estática é uma técnica automática no processo de verificação de software realizado por algumas ferramentas sem a necessidade de que o software tenha sido executado. Para Java exitem duas possibilidades de realizar tal análise na qual uma das técnicas realiza a primeira \'{e} aanálise no código fonte e a outra a realiza no {\it bytecode} do programa segundo N. Ayewah at. al. ~\cite{Ayewah:2008:USA:1439186.1439221}. Neste trabalho ser utilizada a pesquisa baseada no código fonte sem que tenha sido executado devido a flexibilidade e infraestrutura consolidada encontrada no Eclipse AST.

Para obter sucesso atrav\'{e}s nas an\'{a}lises realizadas, \'{e} necess\'{a}rio determinar padr\~{o}es para encontrar caracter\'{i}sticas que dejesam ser evolu\'{i}das para a \'{u}ltima vers\~{a}o da linguagem Java. Estes padr\~{o}es s\~{a}o estabelecidos em uma estrutura que seja capaz de pesquisar nos n\'{o}s da \'{a}rvore da representa\c{c}\~{a}o intermedi\'{a}ria para extrair as informa\c{c}\~{o}es pertinentes.

%Um fato importante é que tal análise somente obt\'{e}m sucesso se forem determinados padr\~{o}es ou comportamento para que sejam pesquisados no software. Neste projeto o tais comportamentos são determinados por {\it visitors} conforme explica Gamma et. al. ~\cite{Gamma:1995} devido a toda infraestrutura a qual as ferramentas do eclipse fornecem facilidade para que seja realizada uma análise baseada em padrões.

A t\'{e}cnica utilizada para pesquisar nos n\'{o}s das \'{a}rvores foi utilizar o padr\~{a}o de projeto \textit{Visitor} proposto por  Gamma et. al.~\cite{Gamma:1995}, pois este possibilitar que seja realizada uma opera\c{c}\~{a}o sobre todos os elementos de uma estrutura,  neste caso a opera\c{c}\~{a}o  \'{e} a pesquisa e a estrutura a representa\c{c}\~{a}o intermedi\'{a}ria.


A verifica\c{c}\~{a}o de software possibilita a detec\c{c}\~{a}o de falhas de maneira precoce durante as fases de desenvolvimento entretanto este n\~{a}o \'{e} o objetivo deste trabalho pois existem ferramentas consolidadas que realizam tal an\'{a}lise de maneira excepcional. Aqui o objetivo principal \'{e} alertar ao desenvolvedor a possibilidade de usar o que h\'{a} de mais recente na linguagem Java.

%Devido a este trabalho de verificação de software é possível detectar falhas de forma precoce nas fases de  desenvolvimento evitando que bugs e falhas sejam introduzidas e até mesmo postergados e isso é uma vantagem existe a economia de tempo com falhas simples, {\it  feedback} rápido para alertar a equipe devido as falhas ocorridas e pode-se ir além de simples casos de testes podendo aprimorar estes para que  fiquem mais rigorosos pois a partir do momento que o analisador encontrar uma falha é possível criar um teste de caso para que esta seja testada aumentando a confiabilidade do software.

%Existe limita\c{c}\~{a}o quanto a capacidade dos analisadores est\'{a}ticos como em \textit{software} desenvolvidos sem qualquer uso de padrões ou sem arquiteturas consolidadas, criado por equipes composta de desenvolvedores inexperientes o qual a ferramente poderá apontar erros que são falsos positivos que são erros detectados que não existem pois o analisador pesquisa por padrões e estruturas consolidadas. Tais problemas são desagradáveis porém não oferecem riscos ao desenvolvimento, podem afetar outras áreas como a de {\it refactoring} a qual poderá encontrar dificuldade em melhorar um código que não segue padrão. Vale ainda ressaltar que a penalidade de encontrar um falso positivo é a perda de tempo em fazer uma inspeção no código para comprovar se é ou não uma falha. Também há a possibilidade de falsos negativos o que cabe ao programador verificar para evitar que tais limitação do analisador não se propague durante o ciclo de desenvolvimento.


%A capacidade dos analisadores est\'{a}ticos 


%\input{capitulos/AnaliseLexica}
