\chapter{Introdução}



\section{Contexto}

Uma premissa na Engenharia de Software é a \emph{natureza evolutiva} do \textit{software}, e, com isso, custos significativos são relacionados com as atividades de manutenção. De forma semelhante, as linguagens de programação evoluem, com o intuito de suprir a demandas atuais e crescente. Geralmente a evolução incorpora benefícios visando aumentar a produtividade e facilitar o desenvolvimento para que com isso obtenha-se aumento na qualidade com um esforço condizente. O que acarreta em grande desafio que é evoluir sistemas existentes por aderir novas características incorporadas em versões atuais da linguagens \cite{Dyer:2013} que o projeto utilize.

Conforme discutido por Overbey e Johnson \cite{Overbey:2009}, características incorporadas raramente são removidas de um programa o que as torna obsoleta e assim acarretando em um maior esforço para a manutenção e uma  sobrecarga na complexidade. Isto gera grande esforço na aprendizagem para novos programadores  que são incorporados nestes projetos o que pode vir a elevar os custos de manutenção. 

Por outro lado, a decisão de não modernizar o código fonte em direção a novas versões da linguagem faz com que a equipe de desenvolvimento alterne entre características atuais e antigas, as quais passam a ser quase um dialeto da linguagem conforme explica Overbey e Johnson em \cite{Overbey:2009}, --- o que aumenta o tempo para conceber um projeto e consequentemente gerindo aumento no custo final projeto.

Uma decisão não tão simples é manter uma porção do código congelada, sem evolução, ao longo projeto devido alguma restrição técnica. O que infelizmente acarreta em uma estagnação de todo um sistema pois não somente o projeto é afetado, mas sim toda uma infraestrutura como compiladores, banco de dados e sistema operacional que, se de alguma forma vierem a ser atualizados com esta porção código estagnado, podem ocasionar problemas como uma queda significativa de desempenho ou até mesmo o sistema parar de funcionar. Devido a esses problemas de código não atualizado, com as versões com estruturas mais atuais, a proposta da realização de refatoração através de ferramentas objetivam atacar essas limitações decorrentes de código obsoleto.

\section{Motivação}
A principal motivação para este trabalho foi o artigo \textit{Regrowing a Language} \cite{Overbey:2009} que realiza um comparativo entre FORTRAN e Java  e como características de que eram foram incorporadas em FORTRAN por quase meio século foi mantida compatibilidade entre versões atuais e modernas entretanto em após FORTRAN-90 alguma características não eram mais suportadas o que acarretou em quebra de compatibilidade com versões atuais o que obrigou desenvolvedores a migrar para versão mais atual.

\section{Problema}
Com a crescente demanda de produção de \textit{software} cada vez menos tempo é dedicado para evolução de características de um \textit{software} o que acarretam em códigos que antigos que raramente são removidos. Em alguns casos a evolução é realizado por esforço individual de algum programador ou quando alguma parte do programa necessita ser retrabalhado. Tendo em vista tal problemática este trabalho tem o intuito de não forçar a evolução de características da linguagem Java mas sim criar um ambiente favorável que facilite identificar construções ultrapassadas. Características essas que serão elencadas mais adiante.

\section{Objetivo}
O principal objetivo deste trabalho é criar um programa capaz de realizar análise estática em projetos desenvolvidos na linguagem Java para caracterizar uso de construções específicas da linguagem com intuito de compreender a forma típica de utilização destas construções desde que atendam alguns requisitos que serão detalhados no capítulo \ref{cap:arquiteruta}.
	
Especificamente para que o objetivo principal seja alcançados foram traçados os seguintes objetivos:

	\begin{itemize}
		\item simplicidade para possibilitar desenvolvedores com pouco conhecimento técnico sejam capazes de criar estruturas que possam pesquisar por construções específicas.
	
	  \item implementar um ambiente de análise estática que recupera informações relacionadas ao uso  de construções da linguagem Java. 
	  
	  \item avaliar o uso de construções nas diferentes versões da linguagem Java, considerando  projetos \textit{open-source}. 
	  
	  \item realizar um \textit{survey} inicial para verificar o porquê da não adoção de algumas construções da linguagem nos projetos. 
	  
	  \item contrastar os resultados das nossas análises com trabalhos de pesquisa recentemente publicados, mas que possivelmente não analisam todas as construções de interesse deste trabalho, em particular 
	  a adoção de construções recentes na linguagem como Expressões Lambda. 
	  
	  \item criar um \textit{software} que facilite o uso para desenvolvedores com pouco conhecimento técnico.
	\end{itemize}


\section{Estrutura do Trabalho}

 Este trabalho está organizado da seguinte forma:
	\begin{itemize}
		\item Capítulo 1: faz uma introdução do tema e o problema que diversos softwares possuem, específica a problemática a ser trabalhada, a motivação principal para a elaboração deste documento e por fim os objetivos deste trabalho;
		
		\item Capítulo 2: apresenta uma revisão da literatura sobre os temas relacionados a essa monografia (incluindo técnicas para análise estática de código fonte) para provê a fundamentação teórica necessária ao entendimento deste trabalho;
		
		\item Capítulo 3: descreve a arquitetura da ferramenta que é resultado deste trabalho e a maneira como qualquer programador possa vir a utilizá-lo para pesquisar suas características desde que atendam requisitos mínimos;
		
		\item Capítulo 4: \textbf{(a)} apresenta os resultados da replicação do estudo realizado por Parnin~\cite{Parnin:ACM2011}, \textbf{(b)} os resultados de uma investigação empírica, seguindo um estilo de pesquisa típico de mineração em 
		repositórios de \textit{software}, \textbf{(c}) compreender como os desenvolvedores 
		Java utilizam os recursos da linguagem de programação, \textbf{(d)} identificar 
		oportunidades de melhoria de código usando construções mais 
		recentes da linguagem de programação e \textbf{(e)} por fim apresentação das considerações finais e sugestões para trabalhos futuros. 
	\end{itemize}



	
%\section{Objetivos Específicos}
%	Criar um analisador estático de código para projetos java, com foco em projetos \textit{opensource}, e através deste pesquisar através da infraestrutura de árvores sintáticas \cite{chomsky1956three} e visitors \cite{Gamma:1995:DPE:186897} provida pela biblioteca \textit{JDT} do eclipse e encontrar construções de código ultrapassadas e verificar se novas características veem sendo adotados pelo desenvolvedores ao longo do projeto.
%	

%A base deste trabalho eh o desenvolvimento de um suporte ferramental que auxilie na evolução de um código legado para reduzir o uso de construções~  obsoletas. Essas ferramentas tem como base a sua construção em linguagem {\it Java} com o intuito de tornar o processo de construção mais ágil e posteriormente aberto para o acoplamento de novos módulos. A construção de uma árvore sintática é um passo onde é feito para cada arquivo de código {\it .Java} e posteriormente de todos os arquivos {\it .Java} contidos em qualquer projeto para posterior análise. Este parser implica em listar todos os arquivos Java e gerar uma \acs{AST} para que posteriormente haja um percorrimento usando um visitor  \cite{Gamma:1995:DPE:186897} nos blocos de código contidos nos nós da \acs{AST}  \cite{Dyer:2014:MBA:2568225.2568295} afim de compará-los como estes com a versão atual.
%
%O processo de refatoração \cite{Schaefer:2010:SIR:1932682.1869485} tem como motivação a reestruturação de código, de forma que o código considerado pelo processo, morto,duplicado ou com perca de desempenho não haja código morto, duplicado ou com perca de desempenho em um determinado trecho de código. Esse processo não tem como premissa a atualização do código para novas estruturas de versões da linguagem mais recentes. Essa nova abordagem de refatoração tem com motivação a retirada de código obsoleto, devido a novas abordagens e estruturas das novas versões, e com baixo desempenho de sistemas sem prejuízo na sua engenharia e funcionamento.
%
%Devido a esse tipo de refatoração de código visa a evolução do código para a uma mais recente com estruturas onde não haja perda de desempenho devido a mudança e também a atualização do código legado para estruturas modernas. Tais estruturas antigas com a ação dessa proposta de refatoração, tendem com o tempo a sair das estruturas providas pela linguagem Java como aconteceu com Fortan 90 como visto em Overbey  \cite{Overbey:2009:RLR:1639949.1640127} e essa abordagem tem o intuito de diminuir a quantidade de estruturas antigas que não fazem mais sentido pois novas estruturas realizam as mesmas funções no interpretador da linguagem Java. As modificações propostas pela ferramenta de refatoração não deverão trazer com que perca de desempenho ou aumento da complexidade do código portanto deixando como uma sugestão a alteração do código ou segmento de código para o usuário a adesão das propostas de refatoração ou não.
%
%A \acs{AST} proposta por Chomsky em 1956 \cite{chomsky1956three},  é uma estrutura de dados que representa estruturas de cadeias sintáticas representada por um esqueleto semântico da linguagem em questão. É constituída através de um \textit{framework} do ambiente de desenvolvimento integrado chamado Eclipse onde o nome desse \textit{framework} é chamado de EclispeJDT agir sobre traz métodos implementados pelo próprio \textit{framework} para o percorrer e ações na árvore sintática. A ideia é transformar inicialmente qualquer código fonte java em uma árvore sintática e devido a isso, o mapeamento da arvore já construída que é muito conveniente para inspecionar o código fonte de um arquivo ou de um projeto com vários arquivos em diferentes diretórios. Com isso é possível realizar ou sugerir ao usuário modificações no código fonte através desta árvore construída e isto seria referenciado automaticamente no código fonte.
%
%A proposta é criar ferramentas de análise estática para códigos fonte da linguagem Java para que possa-se apurar projetos pequenos e posteriormente em projetos {\it open-sources} para a verificação da existência de alguma defasagem \cite{dyer2013large} de estruturas entre qualquer versão da linguagem Java que fora concebido para a versão atual e estável na qual a linguagem se encontra. O desenvolvimento das ferramentas será com a versão mais atual da linguagem Java que neste momento é o Java versão 8 para verificar se os softwares desenvolvidos está versão nesta versão e como acompanharam a evolução de décadas de novas versões sem atualização do código por motivo de engenharia outro qualquer.


\section{Metodologia}
    
    A realização deste trabalho envolveu atividades de revisão da literatura, contemplando a leitura de artigos científicos e livros que abordam a adoção de novas características de linguagem de programação, análise estática e estudos empíricos sobre adoção de características ao longo do lançamento das diferentes versões \cite{Schaefer:ACM2009,Parnin:ACM2011,Overbey:2009,bonifacio:scam2015}. Com isso, foi possível compreender a limitação dos trabalhos existentes e, dessa forma, definir o escopo da investigação. 
    
    Posteriormente, foi necessário buscar uma compreensão sobre como implementar ferramentas de 
    análise estática, e escolher uma plataforma de desenvolvimento apropriada (no caso, foi incorporado as funcionalidades da biblioteca Eclipse-JDT \cite{EclipseJDT}). Posteriormente, foi iniciada a fase de implementação do analisador estático de forma a atender adequadamente a identificação de características da linguagem Java. Além de um ambiente que seja favorecer a inclusão de classes que realizem a pesquisa de características específicas.   
     
    Finalmente, foi seguida uma estrategia de Mineração em repositórios de software, onde foram feitas as análises da adoção de construções da linguagem Java em projetos \textit{open-source}, de forma similar a outros artigos existentes~\cite{pinto-jss:2015,Schaefer:ACM2009, Schaefer:ACM2010, Overbey:2009}.
     