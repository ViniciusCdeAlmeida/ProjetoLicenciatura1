\chapter{Introdução}

% \section{Introdução}
Uma premissa na Engenharia de Software é a \emph{natureza evolutiva} do software, e, com isso, 
custos significativos são relacionados com as atividades de manutenção. De forma semelhante, 
as linguagens de programação evoluem, com o intuito de se adaptarem a novas demandas e trazerem 
benefícios relacionados a produtividade e a melhoria da qualidade dos softwares construídos. Entretanto, um 
desafio inerente é a evolução de sistemas existentes em direção a adoção de novas construções 
disponibilizadas nas linguagens~\cite{Dyer:2013}. 

Conforme discutido por Overbey e Johnson~\cite{Overbey:2009}, 
tal evolução faz com que características obsoletas sejam mantidas e raramente removidas de uma linguagem, 
levando a um aumento da complexidade, esfor\c co de aprendizagem e custos de manutenção do software. 
Al\'{e}m disso, a falta de evolu\c c\~{a}o de um c\'{o}digo fonte em dire\c c\~{a}o a 
novas vers\~{o}es de uma linguagem de programa\c c\~{a}o faz com que a equipe de 
desenvolvimento alterne entre caracter\'{i}sticas atuais e antigas, as quais passam a ser 
quase um dialeto da linguagem--- o que aumenta o tempo para conceber um projeto 
e consequentemente gerindo aumento no custo final projeto.

Uma decisão não tão simples é manter uma porção do código congelada, sem evolução, ao longo projeto devido alguma restrição técnica. O que infelizmente acarreta em uma estagnação de todo um sistema pois não somente o projeto \'{e} afetado, mas sim toda uma infraestrutura como compiladores, banco de dados e sistema operacional que, se de alguma forma vierem a ser atualizados com esta porção código estagnado, 
podem ocasionar problemas como uma queda significativa de desempenho ou até mesmo o sistema parar de funcionar. Devido a esses problemas de código não atualizado, com as versões com estruturas mais atuais, a proposta da realização de refatoração através de 
ferramentas objetivam atacar essas limita\c c\~{o}es decorrentes de código obsoleto.

\section{Objetivos}
	
	O principal objetivo deste trabalho é analisar a adoção de construções da linguagem de programação 
	Java em projetos \textit{open-source}, com o intuito de compreender a forma típica de utilização das construções 
	da linguagem e verificar a adoção ou não das \textit{caracter\'{i}sticas} presentes nas vers\~{o}es 
        mais recentes da linguagem. Especificamente, 
	os seguintes objetivos foram traçados:
	
	\begin{itemize}
	  \item implementar um ambiente de análise estática que recupera informações relacionadas ao uso 
	    de construções da linguagem Java. 
	  
	  \item avaliar o uso de construções nas diferentes versões da linguagem Java, considerando 
	  projetos \textit{open-source}. 
	  
	  \item realizar um \textit{survey} inicial para verificar o porqu\^{e} da não adoção de algumas construções 
	  da linguagem nos projetos. 
	  
	  \item contrastar os resultados das nossas análises com trabalhos de pesquisa recentemente publicados, 
	  mas que possivelmente não analisam todas as construções de interesse deste trabalho, em particular 
	  a adoção de construções recentes na linguagem (como Expressões Lambda). 
	\end{itemize}
	
%\section{Objetivos Específicos}
%	Criar um analisador estático de código para projetos java, com foco em projetos \textit{opensource}, e através deste pesquisar através da infraestrutura de árvores sintáticas \cite{chomsky1956three} e visitors \cite{Gamma:1995:DPE:186897} provida pela biblioteca \textit{JDT} do eclipse e encontrar construções de código ultrapassadas e verificar se novas características veem sendo adotados pelo desenvolvedores ao longo do projeto.
%	

%A base deste trabalho eh o desenvolvimento de um suporte ferramental que auxilie na evolução de um código legado para reduzir o uso de construções~  obsoletas. Essas ferramentas tem como base a sua construção em linguagem {\it Java} com o intuito de tornar o processo de construção mais ágil e posteriormente aberto para o acoplamento de novos módulos. A construção de uma árvore sintática é um passo onde é feito para cada arquivo de código {\it .Java} e posteriormente de todos os arquivos {\it .Java} contidos em qualquer projeto para posterior análise. Este parser implica em listar todos os arquivos Java e gerar uma \acs{AST} para que posteriormente haja um percorrimento usando um visitor  \cite{Gamma:1995:DPE:186897} nos blocos de código contidos nos nós da \acs{AST}  \cite{Dyer:2014:MBA:2568225.2568295} afim de compará-los como estes com a versão atual.
%
%O processo de refatoração \cite{Schaefer:2010:SIR:1932682.1869485} tem como motivação a reestruturação de código, de forma que o código considerado pelo processo, morto,duplicado ou com perca de desempenho não haja código morto, duplicado ou com perca de desempenho em um determinado trecho de código. Esse processo não tem como premissa a atualização do código para novas estruturas de versões da linguagem mais recentes. Essa nova abordagem de refatoração tem com motivação a retirada de código obsoleto, devido a novas abordagens e estruturas das novas versões, e com baixo desempenho de sistemas sem prejuízo na sua engenharia e funcionamento.
%
%Devido a esse tipo de refatoração de código visa a evolução do código para a uma mais recente com estruturas onde não haja perda de desempenho devido a mudança e também a atualização do código legado para estruturas modernas. Tais estruturas antigas com a ação dessa proposta de refatoração, tendem com o tempo a sair das estruturas providas pela linguagem Java como aconteceu com Fortan 90 como visto em Overbey  \cite{Overbey:2009:RLR:1639949.1640127} e essa abordagem tem o intuito de diminuir a quantidade de estruturas antigas que não fazem mais sentido pois novas estruturas realizam as mesmas funções no interpretador da linguagem Java. As modificações propostas pela ferramenta de refatoração não deverão trazer com que perca de desempenho ou aumento da complexidade do código portanto deixando como uma sugestão a alteração do código ou segmento de código para o usuário a adesão das propostas de refatoração ou não.
%
%A \acs{AST} proposta por Chomsky em 1956 \cite{chomsky1956three},  é uma estrutura de dados que representa estruturas de cadeias sintáticas representada por um esqueleto semântico da linguagem em questão. É constituída através de um \textit{framework} do ambiente de desenvolvimento integrado chamado Eclipse onde o nome desse \textit{framework} é chamado de EclispeJDT agir sobre traz métodos implementados pelo próprio \textit{framework} para o percorrer e ações na árvore sintática. A ideia é transformar inicialmente qualquer código fonte java em uma árvore sintática e devido a isso, o mapeamento da arvore já construída que é muito conveniente para inspecionar o código fonte de um arquivo ou de um projeto com vários arquivos em diferentes diretórios. Com isso é possível realizar ou sugerir ao usuário modificações no código fonte através desta árvore construída e isto seria referenciado automaticamente no código fonte.
%
%A proposta é criar ferramentas de análise estática para códigos fonte da linguagem Java para que possa-se apurar projetos pequenos e posteriormente em projetos {\it open-sources} para a verificação da existência de alguma defasagem \cite{dyer2013large} de estruturas entre qualquer versão da linguagem Java que fora concebido para a versão atual e estável na qual a linguagem se encontra. O desenvolvimento das ferramentas será com a versão mais atual da linguagem Java que neste momento é o Java versão 8 para verificar se os softwares desenvolvidos está versão nesta versão e como acompanharam a evolução de décadas de novas versões sem atualização do código por motivo de engenharia outro qualquer.


\section{Metodologia}
    
    A realização deste trabalho envolveu atividades de revisão da literatura, contemplando a leitura 
    de artigos científicos que abordam a adoção de novas características da linguagem Java ao longo do 
    lançamento das diferentes versões para a comunidade de desenvolvedores~\cite{Schaefer:ACM2009, Dyer:2013, Parnin:ACM2011, Overbey:2009, Dyer:ACM2014, Bracha:ACM1998, bonifacio:scam2015}. Com isso, foi 
    possível compreender a limitação dos trabalhos existentes e, dessa forma, definir o escopo da 
    investigação. 
    
    Posteriormente, foi necessário buscar uma compreensão sobre como implementar ferramentas de 
    análise estática, e escolher uma plataforma de desenvolvimento apropriada (no caso, a plataforma 
    Eclipse JDT~\cite{EclipseJDT}). Posteriormente, foi iniciada uma fase de implementação dos 
    analisadores estáticos de forma a atender ao requisito de extensibilidade, ou seja, o ambiente 
    deve favorecer a inclus\~{a}o de novos \emph{analisadores}, levando ao uso de 
    padrões de projetos típicos para essa finalidade como \textit{visitor} e \textit{dependency injection}.
    
     Finalmente, foi seguida uma estrategia de Mineração em Repositórios de Software, onde foram 
     feitas as análises da adoção de construções da linigouagem Java em projetos \textit{open-source}, de forma 
     similar a outros artigos existentes~\cite{Schaefer:ACM2010,pinto-jss:2015,donovan:2004,dinklage:2004, Schaefer:ACM2009, Schaefer:ACM2010, Overbey:2009, Wichmann95industrialperspective, Ayewah:2008:USA:1439186.1439221, bracha1998gj}. 
     
     %todos
	
	%% Após tal entendimento sobre adoção de novas características, fora realiza um estudo sobre análise estática em códigos escritos na linguagem Java o que se torna a base deste trabalho. E logo após a consolidação deste conhecimento, foi realizado a escolha de projetos Java de maior relevância na comunidade \textit{open-source}.
	
	%% Em seguida foi estudada a melhor arquitetura para a elaboração do analisador estático proposto de modo que esta no tivesse um fraco acoplamento entre os módulos necessários e facilitasse a pesquisa de outras características através da injeção do \textit{visitors} \cite{Gamma:1995} usando o \textit{spring framework}~\cite{SPRING_REF}. Mais adiante a arquitetura escolhida será exibida com mais detalhes.

\section{Organiza\c c\~{a}o da Monografia} 

Este documento est\'{a} organizado em cinco cap\'{i}tulos, incluindo esse cap\'{i}tulo de 
introdu\c c\~{a}o. O Cap\'{i}tulo 2 apresenta uma revis\~{a}o da literatura sobre os 
temas relacionados a essa monografia (incluindo t\'{e}cnicas para an\'{a}lise est\'{a}tica 
de c\'{o}digo fonte). O Cap\'{i}tulo 3 apresenta detalhes sobre a implementa\c c\~{a}o do 
analisador est\'{a}tico, constru\'{i}do usando recursos da plataforma \emph{Eclipse Java 
Development Tools}. O Cap\'{i}tulo 4 apresenta o resultado de uma investiga\c c\~{a}o 
emp\'{i}rica, seguindo um estilo de pesquisa t\'{i}pico de minera\c c\~{a}o em 
reposit\'{o}rios de software, que busca (a) compreender como os desenvolvedores 
Java utilizam os recursos da linguagem de programa\c c\~{a}o e (b) identificar 
oportunidades de melhoria de c\'{o}digo usando constru\c c\~{o}es mais 
recentes da linguagem de programa\c c\~{a}o. Finalmente, o Cap\'{i}tulo 
apresenta as considera\c c\~{o}es finais e algumas sugest\~{o}es de 
trabalhos futuros. 
