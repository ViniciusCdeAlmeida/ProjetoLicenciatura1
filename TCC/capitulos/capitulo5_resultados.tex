\chapter{Resultados}
Foram analisados através de mais de 67.648.820 \acs{LOC} nos projetos Ant, Checkstyle, CommonsCollections,  FindBugs,  FreeMind,  Hibernate,  JBoss,  Jetty,  Log4j,  Spring,  SquirrelSql,  Weka,  Xerces.\\

\section{LambdaExpression}
A maior mudança ocorrida em Java 8 foi a introdução de expressões lambda, que tem por definição prover um bloco de código limpo e conciso para representar um interface usando uma simples expressão. Também melhoram a manipulação de \textit{collections} tornando fácil a iteração através de filtros para extração de dados e adiciona novas características de concorrência que aumenta a performance em ambientes \textit{multicores}.\\

\textit{Anonymous inner classes} foram projetada para facilitar o desenvolvedor a tratar seus dados de forma fácil, mas isso não é tão simples como deveria ser, além de suas implementações serem usadas somente em local específico da aplicação, em boa parte de seu uso para tratar eventos decorrentes do usuário ou de algum processamento específico. Expressões Lambda podem vir a substituir \textit{Anonymous inner classes} o que acarreta em uma redução na quantidade de linhas de código significativamente além de reduzir os tipos utilizados no sistema.\\

Dentre os projetos analisados foram encontrados ocorrências de tal característica, \textit{Lambda Expression}, somente nos projetos \textit{Checkstyle}, \textit{Hibernate}, \textit{Jetty} \textit{Spring}, totalizando 774 ocorrências dentre um total de 64.179.440 \acs{LOC}.\\

Tendo em vista que expressões lambdas podem vir a substituir \textit{Anonymous inner classes} e \textit{Types} dos projetos segundo \cite{Java8Lambda}. Foram encontradas nos projetos \textit{CheckStyle}, \textit{Hibernate}, \textit{Jetty} e \textit{Spring}, 2201, 13654, 10016 e 113069 ocorrências respectivamente totalizando em 138940 ocorrências de \textit{Anonymous inner classes}. Com uso de expressões lambda a quantidade de ocorrências de \textit{Anonymous inner classes} e \textit{Types} teria a tendência natural de diminuir seu uso.\\

Um uso corriqueiro de expressão lambda seria para substituir o seguinte bloco do projeto Checkstyle:
\begin{lstlisting}
	//Sem uso de Lambda Expression
	button.addActionListener(new ActionListener(){
		public void actionPerformed(ActionEvent e) {
			System.out.println("button clicked");
		}
	});

	//Usando Lambda Expression
	button.addActionListener(event -> System.out.println("button clicked"));
	
	//###########################################################################
	
	TreeSet<String> paths = new TreeSet<String>(
			new Comparator<String>({
				public int compare(String o1, String o2){
					int paths1 = new StringTokenizer(o1,"/",false).countTokens();
					int paths2 = new StringTokenizer(o2,"/",false).countTokens();
				
					if (paths1 == paths2){
						return o1.compareTo(o2);
					}
				
					return paths2 - paths1;
				}
			}
	);
	
	
	ps = paths.stream().filter(p -> p.o1 != p.o2)
					   .collect(Collectors.toSet());
	
	return new TreeSet(ps);
	
\end{lstlisting}

Como este simples exemplo pode-se verificar do benefício das expressões lambda tendo em vista que  redução do uso de \textit{Anonymous inner classes} além de ser uma forma mais atual. Neste seria um redução de 80\% sobre o código utilizado anteriormente. Além da redução de tipos 3 tipos(\textit{ActionListener}, \textit{ActionEvent} e \textit{void}) para um único método anônimo que acarreta em 300\% na redução de tipos,  se fosse possível aplicar esta características em todas as 138940 ocorrências de \textit{Anonymous inner classes} seria uma redução significativa de \acs{LOC}.

Entretanto diante dos dados coletados é possível afirmar que Expressões Lambda não estão sendo adotadas com este intuito, o que pode leva a crer que esta característica por ser recente ainda pode não ter sido bem acolhida pela comunidade de desenvolvedores para tirar proveito desta  característica para benefício de seus projetos.\\

\section{MultiCatch}
Conforme menciando anteriormente Java 7, introduziu suporte a \textit{MultiCatch} que trouxe a possibilidade de trazer clareza e simplicidade no mecanismo de tratamento de exceção. O que aparentemente esta sendo um recurso pouco utilizado tendo em vista a grande quantidade de oportunidades de utilização desta elegante característica.\\

Foram encotrados um total de 5300 \textit{trys} que possuiam mais de um bloco mais de um \textit{catch}. O que acarretou em 46926 \acs{LOC}, o teste de  similaridade entre os \textit{catchs} foi realizado através de uma chamada a um método exteno que verificava a igualdade podendo ser facilmente alterado para verificar a similaridade baseando em algum algoritmo existente.\\

Um simples \textit{refactoring} unindo estes blocos semelhantes por igualdade acarretaria em redução de 32639 \acs{LOC}  o que  gera uma redução de código duplicado na ordem de 75.95\% onde todos os \textit{catchs} após tal ação teriam um total 14287 \acs{LOC} que torna essa \textit{feature} muito relevante na rescrita de um software além de utilizar o novo estilo de programação proposto nesta versão da linguagem.\\

\begin{figure}[h]
	\center
	\includegraphics[width=1.0\textwidth]{Imagens/ocorrenciasMulticatch}
	\label{fig:Muticatch}
	\caption{Oportunidades de \textit{Multicatch} nos projetos.}
\end{figure}


De forma mais detalhada uma análise sobre uma classe do \textit{Spring 4.2.0.RC2} como exemplo é  \textit{org.springframework.beans.AbstractNestablePropertyAccessor.java}, o qual é possível verificar que tal característica é simples e rápida de ser implantada o que impacta em uma redução significativa do trecho de código mencionado algo entorno de 58\%.\\
\begin{lstlisting}
	// Sem uso de Multicacth 17LOC
	try {
		return this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);
	}catch (ConverterNotFoundException ex) {
		PropertyChangeEvent pce =
			new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);
		throw new ConversionNotSupportedException(pce, td.getType(), ex);
	}catch (ConversionException ex) {
		PropertyChangeEvent pce =
			new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);
		throw new TypeMismatchException(pce, requiredType, ex);
	}catch (IllegalStateException ex) {
		PropertyChangeEvent pce =
			new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);
		throw new ConversionNotSupportedException(pce, requiredType, ex);
	}catch (IllegalArgumentException ex) {
		PropertyChangeEvent pce =
			new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);
		throw new TypeMismatchException(pce, requiredType, ex);
	}
	
// Com uso de Multicatch 10LOC
	try {
		return this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);
	}catch (ConverterNotFoundException ex | IllegalStateException ex | ConversionException ex | IllegalArgumentException ex) {
		PropertyChangeEvent pce = 
			new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, newValue);
		
		if(ex instanceof ConversionException || ex instanceof IllegalArgumentException){
			throw new TypeMismatchException(pce, requiredType, ex);
		}else{
			throw new ConversionNotSupportedException(pce, td.getType(), ex);
		}
	}	
\end{lstlisting}
 

Uma análise mais detalhada sobre \textit{Spring} com 2620 ocorrências o que resulta em  afima que tal procedimento de tratar exceções estão presentes em todas as versões analisadas, iniciando na 3.0.0.M1 lançada em junho de 2009 até a mais recente até o momento 4.2.0.RC2. Para uma análise mais criteriosa será elaborada um detalhamento a partir da versão 4.0.0.M1 até a 4.2.0.RC2 totalizando 927 oportunidades de \textit{multicatch} 35\% das ocorrências no \textit{Spring}.\\

Conforme exibido na figura: \ref{fig:ocorrenciasMulticatchSpring}, obtem-se antes de um \textit{refactoring} uma média de 371 \acs{LOC} e após uma proposta concisa de \textit{refactoring} é possível obter uma média de 106 \acs{LOC} o que proporciona uma redução significativa de 71,46\%.\\

% a possibilidade de que após a criação das classes estes trechos não sofram um significativo \textit{refactoring} e nem uma evolução para essa característica citada o que pode acarretar em uma propagação de um estilo ultrapassado de programação na linguagem \textit{Java}.\\

\begin{figure}[h]
	\center
	\includegraphics[width=1.0\textwidth]{Imagens/ocorrenciasMulticatchSpring}
	\label{fig:ocorrenciasMulticatchSpring}
	\caption{Ocorrências de \textit{Multicatch} Spring 4.X.}
\end{figure}


Dada uma redução significativa é impossível acreditar que projetos tão renomado não fazem uso desta \textit{feature}.  Ignorando uma característica que prove um código mais conciso e elegante conforme a proposta original desta \textit{feature} pela Oracle em 2007.\\


\section{ANT}
Até a última versão deste projeto \cite{apacheAnt}, 1.9.5, não foram encontradas utilização métodos com \textit{vargs}, expressões lambdas, \textit{switch} com \textit{strings} e nem \textit{try} com \textit{resources}.\\

Este projeto faz um bom uso de tratamento de exceções sendo encontrado em toda história de desenvolvimento foram produzidas 28 versões deste e com um total de 34722 blocos \textit{trys}, onde em média foram encontradas 1240 destes blocos por versão. E deste total pode-se verificar um total de 513 ocorrências de blocos \textit{trys} com \textit{catchs} iguais totalizando em 1,5\% de código repetido neste quesito conforme ilustra Figura: \ref{fig:TrysAnt}.\\

\begin{figure}[h]
	\center
	\includegraphics[width=0.7\textwidth]{Imagens/trysAnt}
	\label{fig:TrysAnt}
	\caption{Tratamento de exceção ao longo das releases.}
\end{figure}

Entretanto pode-se constatar conforme ilustrado na Figura: \ref{fig:catchIguais} que em todas as versões do projeto \textit{ANT} possui o tratamento de exceção como blocos \textit{catchs} iguais sendo contabilizado um total de 513 ocorrências e dando atenção especial entre as versões 1.9.0 e 1.9.5. Entretanto a partir da versão 1.9.0 por volta de 2012, java possuía o mecanismo de \textit{multicatch} que fora lançado por volta de 2011 em java 7. Entre as \textit{releases} desta versão foram encontradas em cada um dos 5 lançamentos do \textit{ANT} por volta de 27 ocorrências iguais de \textit{catchs} e acarreta em um total de 135 blocos repetidos. Caso fosse adotado \textit{multicatch} seria reduzido somente a 5 blocos a cada versão existente o que seria uma redução de código repetido em aproximadamente 18\%, e isso acarretaria em um código mais atual e elegante.\\

	\begin{figure}[h]
		\center
		\includegraphics[width=0.7\textwidth]{Imagens/catchsIguais}
		\label{fig:catchIguais}
		\caption{Bloco Try com catchs iguais ao longo das releases.}
	\end{figure}


Outro fato de bastente relevância é que o ANT faz uso de atributos parametrizados indicados na Figura: \ref{fig:atributosParametrizadosAnt}  e métodos parametrizados conforme Figura: \ref{fig:metodosParametrizadosAnt} desde sua versão 1.7.0, dezembro de 2006, o que leva a crer que foi aderido juntamente com o lançamento de \textit{Generics}, o que foi um marco na linguagem Java.\\

Vale ressaltar que de um total de 244137 atributos foi encontrado 1408 destes sendo paramentrizados o que acarreta em menos de 1\% dos atributos são genéricos. E a respeito dos métodos foram encontrados um total de 282216 métodos sendo que deste somente 1080 são métodos parametrizados acarretando em menos de 1\% são parametrizados.\\

O que leva a concluir que apesar do ANT fazer uso de tipos genéricos estes podem estar sendo subutilizados nesse projeto, ou esta característia não é de grande relevância para o projeto.\\



	\begin{figure}[h]
		\center
		\includegraphics[width=0.7\textwidth]{Imagens/atributosParametrizados.png}
		\label{fig:atributosParametrizadosAnt}
		\caption{Atributos parametrizados ao longo das releases.}
	\end{figure}
	
	
	\begin{figure}[h]
		\center
		\includegraphics[width=0.7\textwidth]{Imagens/metodosParametrizados.png}
		\label{fig:metodosParametrizadosAnt}
		\caption{Métodos parametrizados ao longo das releases.}
	\end{figure}
