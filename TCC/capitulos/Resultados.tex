\section{Resultados}\label{sec:resultados}

Essa se\c c\~{a}o descreve os resultados de 
um estudo emp\'{i}rico sobre a adoção de \textit{features} da 
linguagem Java e \textit{standard libraries}, que pode 
ser parcialmente compreendido como uma replicação de um estudo 
existente~\cite{Parnin:ACM2011}. Adicionalmente, a contribuição deste trabalho 
investiga outras quatro características da linguagem Java além de \textit{Java Generics}, 
que são \textit{Java Lambda Expression, Multi-catch, Try-Resource e Switch-String}.  
%onde a questão que direcionou esta contribuição foi \textbf{RQ1: Qual o típico uso de Java Generics e Java Lambda Expressions?}
% me
%Estearc capítulo caracteriza como foi a adoção de construções da linguagem Java, o que pode vir a orientar desenvolvedores a compreender a melhor forma de aplicar algumas desta construções em seus projetos.
%A contribuição desta monografia aborda dois características da linguagem Java, \textit{Java Generics} e \textit{Java Lambda Expression} onde a questão que direcionou este trabalho \textbf{RQ1: Qual o típico uso de Java Generics e Java Lambda Expressions?}

%% A replicação do estudo de \textit{Java Generics} ocorreu através de projetos 
%% opensource. Onde adicionalmente além da replicação do trabalho estudo de Parnin et al.~\cite{Parnin:ACM2011} este adicionou a compreensão de como \textit{Java Generics} se correlaciona com a \textit{release} inicial dos projetos selecionados. 

%% Também foi investigado empiricamente como esta ocorrendo a adoção de \textit{Java Lambda Expression}, vale ressaltar para melhor conhecimento não há estudo empírico que investigou tal questão até o presente momento.
%% Ainda em relação a \textit{Java Lambda Expression} foi levantando um questionamento nas comunidade \textit{opensources} para descobrir qual o comportamento adotado pelas equipes de desenvolvedores após o lançamento desta \textit{feature}. 

Para a realizar essa investigação, quarenta e seis projetos opensource foram escolhidos e separados em 3 
grupos: \textbf{G1} projetos iniciados antes do lançamento de \textit{Java Generics}, \textbf{G2} projetos iniciados 
após o lançamento de \textit{Java Generics} e \textbf{G3} projetos com a última \textit{release} em 2015. 
Alguns destes projetos são os mesmos utilizados em~\cite{Parnin:ACM2011, Dyer:ACM2014, ward2015performance}, 
e também fora separados pela natureza da projeto. Isto \'{e}, os projetos foram 
classificados como \emph{aplicações}, \emph{bibliotecas} e \emph{servidores/banco de dados}, 
conforme Tabela~\ref{tab:systems}. 

%% Para a investigação foram utilizados os \textit{visitors} criados exibidos na  Tabela:~\ref{tab:VisitorsCriados}. A conclusão do estudo de \textit{Java Generics} foram utilizados os seguintes \textit{visitors}:\textit{MethodCallVisitor, FieldAndVariableDeclarationVisitor e TypeDeclarationVisitor} e para o \textit{Java Lambda Expression} estes: \textit{AICVisitor, ExistPatternVisitor, FilterPatternVisitor, LambdaExpressionVisitor, LockVisitor  MapPatternVisitor, TryStatementVisitor, SwitchStringOpportunitiesVisitor e SwitchStatementVisitor}.

  
\begin{table}[p]\footnotesize
\centering
	\caption{Projetos.}
	\begin{tabular}{l|lccrr}\hline
		 & \textbf{System} & \textbf{Release} & \textbf{Group}  & \textbf{LOC} \\\hline \hline
		\multirow{22}{*}{\rotatebox[origin=c]{90}{\textbf{Application}}} 
																 & ANT & 1.9.6 & G1 & 135741\\
																 & ANTLR  & 4.5.1 & G1/G3 & 89935 \\
																 & Archiva  & 2.2.0 & G2/G3 & 84632\\
																 & Eclipse & R4\_5 & G1 & 13429\\
																 & Eclipse-CS & 6.9.0 & G1 & 20426\\
																 & FindBugs & 3.0.1 & G1/G3 & 131351\\
																 & FitNesse & 20150814 & G2/G3 & 72836\\
																 & Free-Mind & 1.0.1 & G1 & 67357\\
																 & Gradle & 2.7 & G2 & 193428\\
																 & GWT & 2.7.0 & G2 & 15421\\
																 & Ivy & 2.4.0 & G2/G3 & 72630\\
																 & jEdit & 5.2.0 & G1 & 118492\\
						   									     & Jenkins & 1.629 & G2/G3 & 113763\\
																 & JMeter & 2.13 & G1/G3 & 111317\\
																 & Maven & 3.3.3 & G1/G3 & 78476\\
																 & Openmeetings & 3.0.6 & G2/G3 & 50496\\
																 & Postgree JDBC & 9.4.1202 & G1/G3 & 43596\\ 
																 & Sonar & 5.0.1 & G2/G3 & 362284\\
																 & Squirrel & 3.4.0 & G1 & 252997\\
																 & Vuze & 5621-39 & G1 & 608670\\
																 & Weka & 3.6.12 & G1 & 274978\\
																 \hline
					
					\multirow{18}{*}{\rotatebox[origin=c]{90}{\textbf{Library}}} 
																  & Axis & 1.4 & G2 & 121820\\		
																  & Commons Collections & 4.4.0 & G1 & 51622\\
																  & Crawler4j & 4.1 & G2/G3 & 3986\\
																  & Hibernate & 5.0.1 & G1/G3 & 541116\\
																  & Isis & 1.9.0 & G2 & 262247\\
																  & JClouds & 1.9.1 & G2/G3 & 301592\\
																  & JUnit & 4.1.2 & G1/G3 & 26456\\
																  & Log4j & 2.2 & G1/G3 & 69525\\
   						   									      & MyFaces & 2.2.8 & G2/G3 & 222865& \\
																  & Quartz & 2.2.1 & G2 & 31968\\
																  & Spark & 1.5.0 & G2/G3 & 31282\\
																  & Spring-Framework & 4.2.1 & G1/G3 & 531757\\
																  & Storm & 0.10.0 & G2/G3 & 98344\\
															      & UimaDucc & 2.0.0 & G2 & 96020\\
																  & Wicket & 7.0.0 & G2/G3 & 211618\\
																  & Woden & 1.0 & G2/G3 & 29348\\
																  & Xerces & 2.11.0 & G1 & 126228\\	
																  \hline		
																					 
					\multirow{8}{*}{\rotatebox[origin=c]{90}{\textbf{Servers - Databases}}} 
																  & Cassandra & 2.2.1 & G2/G3 & 282336\\	
																  & Hadoop & 2.6.1 & G2/G3 & 896615\\
						   									      & Jetty & 9.3.2 & G1 & 299923\\
																  & Lucene & 5.3.1 & G1 & 506711\\
						   									      & Tomcat & 8.0.26 & G1/G3 & 287897\\
						   									      & UniversalMedia Server & 5.2.2 & G3 & 54912\\
						   									      & Wildfly & 9.0.1 & G1/G3 & 392776\\ 
						   									      & Zookeeper & 3.4.6 & G3 & 61708\\ 
						   									      \hline		

	\label{tab:systems}
	\end{tabular}
\end{table}


% \clearpage

\section{Adoção de Java Generics}
Relacionado com a adoção de \textit{Java Generics}, a maioria dos projetos apresenta um porção significativa entre a quantidade de tipos genéricos e a quantidade total de tipos declarados em média (5.31\% e 12.31\%). Pode-se verificar que em 16\% dos sistemas não declaram nenhum tipo genérico e que o projeto \textit{Commons Collections} é o projeto que faz uso 
mais expressivo de tipos parametrizados: 
75\% de todos os tipos declarados são genéricos.

Também foi investigada a relação entre tipos genéricos declarados e todos os tipos considerando os tipos e idade dos sistemas. Tabela~\ref{tab:std} apresenta um resumo desta observação onde é possível verificar que o uso típico de  \textit{Java Generics} não muda significativamente entre os tipos de projetos Java, embora essa proporção seja mais baixa para aplicações e servidores/bancos de dados com versões anteriores ao lançamento do Java SE 5.0.

\begin{table}[h!]
	\centering
	\caption{Resumo dos tipos agrupados por idade e do tipo dos projetos.}
	\begin{tabular}{ccccc} \hline 
		Tipo de Projeto & Antes Java SE 5.0 & Tipo & Tipo Genérico & Ratio(\%) \\ \hline\hline
		Aplication & Yes & 18168 & 177 & 0.97 \\
		Aplication & No & 16148 & 744 & 4.61 \\
		Library & Yes & 21537 & 1198 & 5.56 \\
		Library & No & 22639 & 947 & 4.18 \\
		Server/Database & Yes & 18038 & 552 & 3.10 \\ 
		Server/Database & No & 11790 & 760 & 6.45 \\ \hline
	\end{tabular}
	\label{tab:std} %std means summary of type declarations
\end{table}


Existe um número expressivo de atributos e variáveis declaradas como instâncias de tipos genéricos. Considerando um total de \num{925925}\ variáveis e atributos declarados em todos os projetos, \num{84880} são instâncias de tipos genéricos, aproximadamente 10\% de todas as declarações. Além disso, a partir destes atributos e variáveis declaradas como instância de tipos genéricos, quase 17\% são instâncias dos tipos presentes na Tabela~\ref{tab:tipoXnumeroInstancia}. Note que, em um trabalho anterior, Parning et al.~\cite{Parnin:ACM2011} apresenta \texttt{List$<$String$>$} com quase 25\% de todas as ocorr\^{e}ncias 
de tipos genéricos. O que pode ser confirmado que \texttt{List$<$String$>$} ainda é o tipo com maior frequência de uso entre os tipos genéricos. 
Por outro lado, \'{e} importante observar que, em um total de 
\num{730720} métodos, apenas \num{6157} (0.84\%) 
são \emph{métodos parametrizados.}

\begin{table}[ht]
	\centering
	\caption{Tipo declarado X Número de instância}
	\begin{tabular}{cc}
		\hline
		Tipo & Número de Instância\\ 
		\hline \hline
		\texttt{List$<$String$>$} & 4993 \\ 
		\texttt{Class$<$?$>$} & 3033 \\ 
		\texttt{Set$<$String$>$} & 2872 \\ 
		\texttt{Map$<$String,String$>$} & 2294 \\ 
		\texttt{Map$ < $String,Object$>$} & 1554 \\ \hline
	\end{tabular}
	\label{tab:tipoXnumeroInstancia} %std means summary of type declarations
\end{table}

Também foi investigado o uso mais avançado de \textit{Java Generics}, incluindo construções que fazem polimorfismo n\~{a}o universal. Com este recurso é possível criar classes paramétricas que aceitam qualquer tipo \textbf{T} 
como argumento, uma vez que um tipo \textbf{T} satisfaça um determinada 
pré-condição. Isto é, o tipo \textbf{T} deve ser um qualquer um subtipo (usando o modificador \textit{extends}) ou um super-tipo ( usando o modificador \textit{super}) de um determinado tipo existente. Estes modificadores podem 
ser usados tanto na declaração de novos tipos, bem como na declaração de campos e variáveis em combinação com o \textit{wildcard} (\textbf{?}). A partir 
de \num{4355} tipos genéricos declarados em todos os sistemas, 
observou-se que \num{1271} (aproximadamente 30\%) usam alguns 
desses modificadores (\textit{extends}, \textit{super}, ou \textit{?}). Notavelmente, o modificador \textit{extends} é o mais comum, e está presente em todos os tipos genéricos que usam os modificadores \textit{?} e \textit{super}. Alguns casos de uso são combinações de modificadores, como no exemplo da Listing:~\ref{lst:tp}, onde a classe IntervalTree (projeto CASSANDRA) é parametrizado de acordo com três parâmetros de tipo (C, D e I). Com relação aos campos e declarações de variáveis, quase 13\% de todos os casos genéricos usam o \textit{?} \textit{wildcard} e 3,13\% usam o \textit{extends}.

\begin{lstlisting}[caption={Declaração não trivial de Generics.}\label{lst:tp},language=Java] 
public class IntervalTree<C extends Comparable<? super C>, D, I extends Interval<C, D>> implements Iterable<I>{
  //...
}
\end{lstlisting}


Os resultados mostram que \textit{Java Generics} é uma \textit{feature} em que corresponde a 5\% de todos os tipos declarados dos sistemas, portanto, uma grande quantidade de código repetido e coerções de tipos foram evitados usando tipos genéricos. Além disso, a partir desses tipos genéricos, quase 30\% usam um recurso avançado (como extends e super envolvendo parâmetros de tipo). Também foi observado que quase 10\% de todos os atributos e variáveis declaradas são tipos genéricos, embora a maior parte são instâncias de tipos genéricos da biblioteca \textit{Java Collection}. Finalmente, embora Parnin et al.~\cite{Parnin:ACM2011} argumentam que uma classe como \textit{StringList} pode cumprir 25\% das necessidades de desenvolvedores entretanto, o uso de \textit{Java Generics} não deve ser negligenciada devido aos benefícios que são incorporados ao sistema.



\section{Adoção de Java Lambda Expression}
Considerando os sistemas pesquisados, o uso de Java \textit{Lambda Expression} ainda é muito limitado, independente das expectativas e reivindicações sobre os possíveis benefícios dessa construção. Na verdade, apenas cinco projetos adotam este recurso conforme a Tabela~\ref{tab:adocaoLambda}, embora o cenário de uso (quase 90\%) está relacionado com testes unitários. 

Essa observa\c c\~{a}o levou a um questionamento se algum 
\textit{framework} de teste unitário (particularmente o 
Mockito) conduzia os desenvolvedores 
a usar express\~{o}es lambda em testes automatizados. 
Entretanto após analisar manualmente o código fonte não foi encontrado nenhum indício da adoção de Java\textit{ Lambda Expresssion} para testes unitários o que pode-se concluir que tais testes ocorreram de forma \textit{ad-hoc} através de esforços individuais de cada desenvolvedor.
Ou seja, a partir de milhares de casos de testes unitários no \textit{Hibernate}, apenas poucos testes para uma biblioteca específica (relacionados com \textit{cache}) usam Java\textit{ Lambda Expression}. Este pequeno uso de Java\textit{ Lambda Expression} pode ser principalmente motivado por uma decisão estratégica do projeto para evitar a migração do código fonte ultrapassado para a versão mais atual.

\begin{table}[h]
	\centering
	\caption{Ocorrências de Expressões Lambda.}
	\begin{tabular}{cc}
		\hline
		Sistema & Ocorrências Expressões Lambda\\ 
		\hline \hline
		\texttt{Hinernate} & 168 \\ 
		\texttt{Jetty} & 2 \\ 
		\texttt{Lucene} & 11 \\ 
		\texttt{Spark} & 77 \\ 
		\texttt{Spring-framework} & 121 \\ \hline
	\end{tabular}
	\label{tab:adocaoLambda} %std means summary of type declarations
\end{table}


Foi enviado mensagens para grupos do desenvolvedores sobre o assunto, e algumas respostas esclarecem a atual situação da adoção de Java\textit{ Lambda Expression}. Primeiro de tudo, para sistemas estabelecidos, as equipes de desenvolvedores muitas vezes não podem assumir que todos os usu\'{a}rios sejam capazes de migrar para uma nova versão do Java\textit{ Runtime Environment}. Por exemplo, o seguinte \textit{post} explica uma das razões para não adotar algumas construções adicionada a linguagem Java: 

\begin{quotation}
``É, sobretudo, para permitir que as pessoas que estão vinculados (por qualquer motivo) a versões mais antigas do ~\acs{JDK} utilizem nosso software. Há um grande número de projetos que não são capazes de usar novas versões do ~\acs{JDK}. Eu sei que este é um tema controverso e acho que a maioria de gostaria de usar todos esses recursos. Mas não devemos esquecer as pessoas que usam 
nosso software em seu trabalho diário'' (http://goo.gl/h0uloY).
\end{quotation}

Além disso, uma abordagem inicial utilizando uma nova característica da linguagem é mais oportunista. Ou seja, os desenvolvedores não migram todo o projeto, mas em vez disso as modificações que introduzem estas novas construções de linguagem ocorrem quando eles estão implementando novas funcionalidades. Duas respostas a estas perguntas deixam isso claro: 

\begin{quotation}
``Nós tentamos evitar reescrever grandes trechos de código base, sem uma boa razão. Em vez disso, tirar proveito dos novos recursos de linguagem ao escrever novo código ou refatoração código antigo.'' (https://goo.gl/2WgjVG) 
\end{quotation}

\begin{quotation}
 ``Eu, pessoalmente, não gosto da ideia de mover todo o código para uma nova versão Java, eu modifico áreas que atualmente trabalho.''  (http://goo.gl/ GQ4Ckn).
\end{quotation}

 Observe que não se pode generalizar estas conclusões com base nessas respostas, uma vez que não foi 
conduzida uma investiga\c c\~{a}o emp\'{i}rica mais estruturada em termos de 
\emph{survey}. No entanto, estas respostas podem apoiar trabalhos contra a adoção antecipada de novos recursos de linguagem por sistemas estabelecidos com uma enorme comunidade de usuários.

Também foi efetuada uma busca no \textit{STACK OVERFLOW} tentando descobrir se Java\textit{ Lambda Expression} é um tema discutido atualmente ou não~\footnote{Última pesquisa realizada em Novembro 2015}, utilizando \textit{tags} Java e Lambda. Foi encontrada mais de \num{1000} questões respondidas. Este número é bastante expressivo, quando considerou-se uma busca por questões marcadas com as \textit{tag} de Java Generics levou-se a um número próximo de \num{10000} perguntas, embora \textit{Generics} tenha sido introduzido há mais de dez anos. Possivelmente, Java\textit{ Lambda Expression} está sendo usado principalmente em pequenos projetos e experimentais. Isso pode contrastar com os resultados anteriores~\cite{Dyer:ACM2014}, que sugerem uma adoção antecipada de novos recursos da linguagem (mesmo antes de lançamentos oficiais). Com base nesses resultados, pode-se argumentar que a adoção antecipada de novos recursos da linguagem ocorre em projetos pequenos e experimentais.

Tamb\'{e}m foi feita uma investiga\c c\~{a}o sobre as oportunidades de adoção de Java\textit{ Lambda Expression} nos projetos estudados. Desta forma, foi complementado um testou maior~\cite{gyori2013crossing},  que investigou as mesmas questões porém eu um número de  inferior de projetos. Existem dois cenários típicos para \textit{refactoring} utilizando Expressões Lambda: \textit{Annonymous Inner Classes} (\acs{AIC}) e \textit{Enhanced for Loops} (\acs{EFL}). É importante notar que nem todas as ~\acs{AIC}s e ~\acs{EFL}s podem ser reescritas utilizando Java\textit{ Lambda Expression}, e existem rígidas precondições que são detalhadas em ~\cite{gyori2013crossing}. Neste trabalho foi utilizado uma abordagem mais conservadora para considerar se é possível refatorar\textit{Enhanced for Loops} para Java\textit{ Lambda Expression}, o que evita falsos positivos.  Entretanto, foram consideradas somente 
oportunidades de refatorar~\acs{EFL} para Java\textit{Lambda Expression} em tr\^{e}s 
casos particulares: \textsc{EXIST PATTERN}, \textsc{BASIC FILTER PATTERN} e 
\textsc{BASIC MAPPING PATTERN}, descritos nas 
Listagens:~\ref{lst:exist},~\ref{lst:filter} e~\ref{lst:map}.

\begin{lstlisting}[caption={EXIST PATTERN.}\label{lst:exist},language=Java]
//...
for(T e : collection){
  if(e.pred(args)){
    return true;
  }
}
return false;

//pode ser refatorado para:
return collection.stream().anyMatch(e->pred(args));
\end{lstlisting}

\begin{lstlisting}[caption={FILTER PATTERN.}\label{lst:filter},language=Java] 
//...
for(T e : collection){
  if(e.pred(args)){
    otherCollection.add(e);
  }
}

//pode ser refatorado para:
collection.stream().filter(e->pred(args).forEach(e->otherCollection.add(e));
\end{lstlisting}

\begin{lstlisting}[caption={MAP PATTERN.}\label{lst:map},language=Java] 
//...
for(T e : collection){
  e.foo();
  e = blah();
  otherCollection.add(e);
}

//pode ser refatorado para:

collection.stream().forEach(e->{
  e.foo();
  e = blah();
  otherCollection.add(e);
});
\end{lstlisting}

Mesmo com uma abordagem conservadora, foram encontradas \num{2496} casos em que poderiam 
ser efetuados o \textit{refactoring}~\acs{EFL} para Expressão Lambda. 
Atualmente, a maior parte destes 2190 casos correspondem ao \textsc{MAP PATTERN}.

%% Também foi investigado o típico uso de características de concorrência em Java. Foi encontrado que 39 de 43 dos sistemas declarados classes que herdam de \textit{Thread} ou implementam a interface \textit{Runnable}. A Tabela~\ref{tab:concorrenciaJava} apresenta a relação destas declarações quando considerado o número total de tipos declarados, agrupados projetos estudados. Note que o uso de classes que herdam de \textit{Thread} ou implementam \textit{Runnable} é elevado considerando os casos de servidores e database.

%% \begin{table}[h]
%% 	\centering
%% 	\caption{Classes concorrentes que \textit{extends Thread} ou implementam \textit{Runnable}.}
%% 	\begin{tabular}{cc}
%% 		\hline
%% 		Tipo Sistema & Relação dos Tipos de Concorrência\\ 
%% 		\hline \hline
%% 		\texttt{Applications} & 0.69 \\ 
%% 		\texttt{Libraries} & 0.34 \\ 
%% 		\texttt{Serves and database} & 1.52 \\ \hline
%% 	\end{tabular}
%% 	\label{tab:concorrenciaJava} %std means summary of type declarations
%% \end{table}

\subsection{Análises adicionais}
Os principais resultados dessa monografia estavam relacionados à investigação discutida nas seções anteriores. Por outro lado, a infraestrutura construída  durante a realização desse trabalho favorece a investigação de outras construções da linguagem Java. Conforme discutido por Jeffrey L. Overbey et 
al.~\cite{Overbey:2009}, desenvolvedores Java mantém construções ultrapassas ao longo histórico de versões de um  software o que de fato é possível devido a compatibilidade mantida entre as versões da linguagem. Tais construções somente seriam evitadas caso ocorresse uma ruptura desta filosofia de compatibilidade da linguagem tal como ocorreu na linguagem Fortran~\cite{Overbey:2009}, 
quando foi  introduzido o paradigma de orientação a objetos--- levando a quebra de compatibilidade com versões anteriores da linguagem Fortran.

Baseado nesta assertiva, foi feita uma investigação adicional que visa minerar o uso de construções obsoletas 
em código fonte existente e encontrar possíveis casos de trechos de código que poderiam ser 
evoluídos ao longo das versões da linguagem Java. Essas situações caracterizam cenários potenciais de melhoria de código e preservam 
o comportamento do sistema (tipicamente um \textit{refactoring}), com o objetivo único de usar construções introduzidas nas versões 7 e 8 da linguagem Java.
Dentre as evoluções da linguagem, essa se\c c\~{a}o descreve os resultados 
para se identificar oportunidades de adoção das características 
\texttt{multi-catch, try resource e switch com string} 
bem como se as mesmas estão sendo adotadas.
%
%\begin{itemize}
%\item Adoção e oportunidades de Multicatch.
%\item Adoção de Try com resource.
%\item Adoção e oportunidades de Switch com String.
%\item Adoção de Expressões Lambda.
%\item Oportunidades de exist - Expressões Lambda.
%\item Oportunidades de filter - Expressões Lambda.
%\item Oportunidades de map - Expressões Lambda.
%\end{itemize}
%
%Além da replicação do estudo de Parnin .et.al~\cite{Parnin:ACM2011} e diferentemente do trabalho original, estender  como objetivo compreender como a adoção de Generics se correlaciona com a data de lançamento inicial dos
%projetos selecionados. 

%Para a realização deste trabalho foram escolhidos 47 projetos open-source separados em 3 grupos \textbf{G1} projetos iniciados antes do lançamento de \textit{Generics}, \textbf{G2} projetos iniciados após o lançamento de \textit{Generics} e \textbf{G3} projetos com a última \textit{release} em 2015. Alguns destes projetos são os mesmos utilizados em, \cite{Parnin:ACM2011, Dyer:ACM2014, ward2015performance}, este também fora separados pela natureza da aplicação,  Aplicações, Bibliotecas e Servidores/Banco de dados conforme tabela:~\ref{tab:systems} o que totalizou mais de 8.5M de~\acs{LOC}.

%Os dados contidos no arquivos ~\acs{CSV} foram processados e analisados com o software R~\cite{R} versão (3.1.2) além da biblioteca ggplot~\cite{ggplot} versão (1.0.1) para gerar gráficos mais consistentes.

%\input{capitulos/Lambda}
\input{capitulos/Multicatch}
\input{capitulos/TryResource}
\input{capitulos/SwitchString}
