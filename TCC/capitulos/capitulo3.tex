%\input{capitulos/HistoriaDaLinguagem}
%\input{capitulos/AspectosEvolutivos}
\chapter{Fundamentação}

Conforme mencionado no capítulo anterior, o principal objetivo deste trabalho de conclusão de curso é 
identificar oportunidades de evolução de código em projetos que utilizam recursos anteriores a Java 7 e Java 8, 
algo necess\'{a}rio para o contexto de reestrutura\c c\~{a}o de c\'{o}digo que visa adequar um c\'{o}digo 
existente para usar constru\c c\~{o}es mais atuais de uma determinada de linguagem de programa\c c\~{a}o 
(no caso, a linguagem Java). Importante destacar que as vers\~{o}es da linguagem Java mencionadas anteriormente
introduziram novos recursos, tais como: \texttt{multi-catch}, \texttt{try-with-resourse}, \texttt{switch-string} 
e \texttt{lambda expressions}; e que esse tipo de evolução constitui uma nova perspectiva de \textit{refactoring}, que se caracteriza 
por uma transforma\c c\~{a}o de c\'{o}digo que preserva comportamento e que passa a usar  
novas constru\c c\~{o}es da linguagem de programa\c c\~{a}o (conforme defendido por Overbey and Johnson~\cite{Overbey:2009}). 

Para atingir o objetivo do trabalho de conclus\~{a}o de curso, foi necess\'{a}rio estudar temas relacionados 
\`{a} evolu\c c\~{a}o da linguagem Java, engenharia de linguagens de software (ou no Ingl\^{e}s Software 
Language Engineering) e refatoramento de c\'{o}digo (\emph{code refactoring}).  Para dar mais clareza ao leitor 
sobre essas temáticas, esse capítulo apresenta uma vis\~{a}o geral sobre esses temas. Note que n\~{a}o foi objetivo
deste trabalho implementar um mecanismo de transforma\c c\~{a}o de c\'{o}digo, mas sim construir um suporte ferramental 
efetivo para compreender como os desenvolvedores usam as constru\c c\~{o}es existentes na linguagem Java e {\bf identificar 
oportunidades de melhoria de c\'{o}digo}, algo essencial para permitir a atualiza\c c\~{a}o de um c\'{o}digo existente 
que usa constru\c c\~{o}es ultrapassadas de uma linguagem de programa\c c~{a}o. 
 
\section{Evolução Linguagem Java}\label{sec:evolucaoJava}

No começo da década de 90 um pequeno grupo de engenheiros da SUN Microsystems chamados de "\textit{Green Team}" acreditava que a próxima grande área da computação seria a união de equipamentos eletroeletrônicos com os computadores. O "\textit{Green Team}" liderado por James Gosling, demonstrou a linguagem de programação Java, que foi desenvolvida pela equipe e originalmente era chamada de Oak, foi desenvolvida para dispositivos de entretenimento como aparelhos de TV a cabo, porém não foi bem aceita no meio. Em 1995 com a massificação da Internet, a linguagem Java teve sua primeira grande aplicação o navegador Netscape.

Java é uma linguagem de programação de propósito geral orientada a objetos, concebida especificadamente para ter poucas dependências de implementação o que acarreta que uma vez que a aplicação foi desenvolvida ela poderá ser executada em qualquer ambiente computacional.

Na sua primeira versão chamada de Java 1 (\acs{JDK} 1.0.2) haviam oito pacotes básicos do java como: \texttt{java.lang}, \texttt{java.io}, \texttt{java.util}, \texttt{java.net}, \texttt{java.awt}, \texttt{java.awt.image}, \texttt{java.awt.peer} e \texttt{java.applet}. Com isso passou a ser a adotada para o desenvolvimento de ferramentas populares na época como o Netscape 3.0 e o Internet Explorer 3.0.

Sua segunda versão foi o \acs{JDK}1.1 \cite{JDK1.1} que trouxe ganhos em funcionalidades, desempenho e qualidade. Novas aplicações também surgiram como : JavaBeans, aprimoramento do \acs{AWT}, novas funcionalidades como o \acs{JDBC}, acesso remoto ao objeto \acs{RMI} e suporte ao padrão Unicode 2.0.

A terceira versão Java 2 (\acs{JDK} 1.2) ofereceu melhorias significativas no desempenho, um novo modelo de segurança flexível e um conjunto completo de Interface de Programação de Aplicação \acs{API}'s. O modelo de "\textit{sandbox}" foi ampliado para dar aos desenvolvedores, usuários e administradores de sistema a opção de especificar e gerenciar um conjunto de políticas de segurança flexível que gerenciam as ações de uma aplicação ou \textit{applet} que pode ou não ser executada. Foi introduzido o suporte nativo a \textit{thread} para o ambiente operacional Solaris e também a compressão de memória para classes carregadas. Alocação de memória com melhor desempenho e aprimoramento da coleta de lixo. Arquitetura de máquina virtual conectável para outras máquinas virtuais, incluindo a \textit{Java HotSpot VMNew}. \textit{Java Native Interface }\acs{JNI} de conversão. O novo conjunto de componentes de projeto, \acs{GUI} (\textit{Swing}). \acs{API} Java 2D que fornece novos recursos gráficos 2D e \acs{AWT}, bem como suporte para impressão. Java \textit{plug-in} para navegadores, fornecendo um tempo de execução totalmente compatível com a máquina virtual Java amplamente implantadas em navegadores. A inclusão do \acs{JDBC} que fornece um acesso mais fácil aos dados para consultas mais flexíveis, suporte ao SQL3 e trouxe melhor desempenho e estabilidade promovidos por cursores de rolagem.


Em 8 de Maio de 2000 foi anunciado o Java 2 versão 1.3 que trouxe ganho de desempenho em relação a primeira versão da JS2E de cerca de 40\%  no tempo de {\it  start-up}. O {\it Java HotSpot VM} cliente e suas bibliotecas atentando ao desempenho ao fazer o J2SE versão 1.3 a {\it release} o mais rápido até à data. Novos recursos, como o {\it caching applet} e instalação do pacote opcional Java através da tecnologia Java {\it  Plug-in} para aumentar a velocidade e a flexibilidade com que os {\it applets} e aplicativos baseados na tecnologia Java podem ser implantados. Java {\it  Plug-in} tecnologia é um componente do ambiente de execução Java 2 que permite Java {\it applets} e aplicativos executarem. O novo suporte para \acs{RSA}, assinatura eletrônica, com um gerenciamento mais confiável e dinâmico, certificados X.509, e verificação de arquivos o que significa aumento das possibilidades que os desenvolvedores tem para proteger dados eletrônicos. Uma série de novos recursos e ferramentas de desenvolvimento da tecnologia J2SE versão 1.3 que permite o desenvolvimento mais fácil e rápido de aplicações baseadas na tecnologia {\it web} ou Java {\it  standalone} de alto desempenho. A adição de RMI/IIOP e o JNDI para a versão 1.3, melhora na interoperabilidade J2SE. Melhora da conectividade com sistemas de {\it  back-end} que suportam CORBA. O novo suporte que o JNDI fornece acesso aos diretórios que suportam o populares LDAP Lightweight Directory Access Protocol, entre outros.


No ano de 2002 no dia 6 de Fevereiro, foi lançado a J2SE versão 1.4. Com a versão 1.4, as empresas puderam usar a tecnologia Java para desenvolver aplicativos de negócios mais exigentes e com menos esforço e em menos tempo. As novas funcionalidades como a nova I/O e suporte a 64 bits. A J2SE se tornou plataforma ideal para a mineração em grande escala de dados, inteligência de negócios, engenharia e científicos. A versão 1.4 forneceu suporte aprimorado para tecnologias padrões da indústria, tais como SSL, LDAP e CORBA a fim de garantir a operacionalidade em plataformas heterogêneas, sistemas e ambientes. Com o apoio embutido para XML, a autenticação avançada, e um conjunto completo de serviços de segurança, está versão forneceu base para padrões de aplicações Web e serviços interoperáveis. O J2SE avançou para o desenvolvimento de aplicativos de cliente com novos controles de GUI, acelerou Java 2D, a performance gráfica, internacionalização e localização expandida de apoio, novas opções de implantação e suporte expandido para o até então {\it Windows XP}.

Com a chegada da \acs{JSE2} versão 1.5 (Java 5.0) em 30 de Setembro de 2004, impulsionou benefícios extensivos para desenvolvedores, incluindo a facilidade de uso, desempenho global e escalabilidade, monitoramento do sistema e gestão e desenvolvimento. O Java 5 foi derivado do trabalho de 15 componentes Java Specification Requests (JSRs) englobando recursos avançados para a linguagem e plataforma. Os líderes da indústria na época que participam no grupo de peritos J2SE 5.0 incluiram: Apache Software Foundation, Apple Computer, BEA Systems, Borland Software Corporation, Cisco Systems, Fujitsu Limited, HP, IBM, Macromedia, Nokia Corporation, Oracle, SAP AG, SAS Institute, SavaJe Technologies e Sun Microsystems.

Houve novas funcionalidades foram implementadas como: facilidade de desenvolvimento onde os programadores da linguagem Java pode ser mais eficiente e produtivos com os recursos de linguagem Java 5 que permitiram a codificação mais segura. Nesta versão surgiu o {\it Generics} ~\cite{OracleGenerics, bracha1998gj}, tipos enumerados, metadados e autoboxing de tipos primitivos permitindo assim uma fácil e rápida codificação. Monitoramento e gestão permitindo um foco para a nova versão da plataforma, a aplicativos baseados na tecnologia Java {\it Virtual Machine} que passou a ser monitorado e gerenciado com o {\it built-in} de suporte para Java {\it Management Extensions}. Suporte para sistemas de gestão empresarial baseados em SNMP também é viável. Um olhar novo sobre aplicativos baseado na tecnologia Java padrão e proporcionou um melhor desenvolvimento GUI para aplicativos baseados na tecnologia Java. A J2SE 5.0 teve suporte completo a internacionalização e também inseriu suporte para aceleração de hardware por meio da {\it API OpenGL } e também para o sistema operacional Solaris e sistemas operacionais da distribuição Linux. **Maior desempenho e escalabilidade com a nova versão que incluiu melhorias de desempenho, redução no tempo de inicialização, um menor consumo de memória e JVM auto ajustável para gerar maior desempenho geral do aplicativo e desenvolvimento em J2SE 5.0 em relação a versões anteriores.

Java 1.6 (Java 6) foi divulgado em 11 de dezembro de 2006. Tornou o desenvolvimento mais fácil, rápido e eficiente em termos de custos e ofereceu funcionalidades para serviços web, suporte linguagem dinâmica, diagnósticos e aplicações {\it desktop}. Com a chegada dessa nova versão do Java houve combinação com o {\it NetBeans} IDE 5.5 fornecendo aos desenvolvedores uma estrutura confiável, de código aberto e compatível, de alta performance para entregar aplicativos baseados na tecnologia Java mais rápido e fácil do que nunca. O {\it NetBeans} IDE fornece uma fonte aberta e de alto desempenho, modular, extensível, multiplataforma Java IDE para acelerar o desenvolvimento de aplicações baseadas em software e serviços {\it web}. O Java 1.6 ajudou a acelerar a inovação para o desenvolvedor, aplicativos de colaboração {\it online} e baseadas na {\it web}, incluindo um novo quadro de desenvolvedores \acs{API}'s para permitir a mistura da tecnologia Java com linguagens de tipagem dinâmica, tais como PHP, Python, Ruby e tecnologia JavaScript. A Sun também criou uma coleção de mecanismos de {\it script} e pré-configurado o motor {\it JavaScript Rhino} na plataforma Java. Além disso, o software inclui uma pilha completa de clientes de serviços web e suporta as mais recentes especificações de serviços {\it web}, como \acs{JAX-WS} 2.0, \acs{JAXB} 2.0, \acs{STAX} e \acs{JAXP}. A plataforma Java 1.6 forneceu ferramentas expandidas para o diagnóstico, gestão e monitoramento de aplicações e também inclui suporte para o novo {\it NetBeans Profiler} 5.5 para {\it Solaris DTrace } e, uma estrutura de rastreamento dinâmico abrangente que está incluído no sistema operacional Solaris 10. Além disso, o software Java SE 6 aumenta ainda mais a facilidade de desenvolvimento com atualizações de interface ferramenta para o {\it Java Virtual Machine} (\acs{JVM}) e o {\it Java Platform Debugger Architecture} (\acs{ACDP}).

Java 7 ~\cite{JSE7} foi lançado no dia 28 de julho de 2011. Essa versão foi resultado do desenvolvimento de toda a indústria o que envolveu uma revisão de código aberto e extensa colaboração entre os engenheiros da {\it Oracle} e membros do ecossistema Java em todo o mundo através da comunidade {\it OpenJDK} e do {\it Java Community Process} (\acs{JCP}). Compatibilidade com versões anteriores de Java 7 com versões anteriores da plataforma a fim de preservar os conjuntos de habilidades dos desenvolvedores de software Java e proteger os investimentos em tecnologia Java. As alterações da linguagem ajudaram a aumentar a produtividade do desenvolvedor e simplificar tarefas comuns de programação, reduzindo a quantidade de código necessário, esclarecendo sintaxe e tornar o código com mais legibilidade. Melhor suporte para linguagens dinâmicas incluindo: Ruby, Python e JavaScript, resultando em aumentos substanciais de desempenho no \acs{JVM}. Uma nova API {\it multicore ready} que permite aos desenvolvedores para se decompor mais facilmente problemas em tarefas que podem ser executadas em paralelo em números arbitrários de núcleos de processador. Uma interface de I/O abrangente para trabalhar com sistemas de arquivos que podem acessar uma ampla gama de atributos de arquivos e oferecem mais informações quando ocorrem erros. Novos recursos de rede e de segurança. Suporte expandido para a internacionalização, incluindo suporte a Unicode 6.0. Além de versões atualizadas das bibliotecas padrão.

Com o lançamento do Java SE 8 em 18 de Março de 2014, permitiu uma maior produtividade e desenvolvimento de aplicativos significativos aumentos de desempenho através da redução de linhas de código, {\it collectons} melhoradas, modelos mais simples de programação paralela e uso mais eficiente de processadores {\it multi-core}. As principais características do \acs{JDK} 8 são o projeto Lambda, {\it Nashorn JavaScript Engine}, um conjunto de perfis compactas e a remoção da "geração permanente" do {\it HotSpot Java Virtual Machine} (\acs{JVM}). A \acs{JDK} 8 alcançou desempenho recorde mundial para 4 sistemas de soquete em servidores baseados em Intel e NEC por 2 sistemas de soquete em servidores SPARC da Oracle T5, com uma melhoria de desempenho de 12\% para 41\% em comparação com o JDK 7 na mesma configuração de Oracle.

%O \acs{JDK} 8 adicionou novas funcionalidades como as expressões lambda com as seguintes características: referências a métodos são compactas e maior legibilidade expressões lambda para métodos que já têm um nome. Métodos padrão que permitem adicionar novas funcionalidades para as interfaces de suas bibliotecas e assegurar a compatibilidade binária com o código escrito para versões mais antigas dessas interfaces. Eles métodos de interface que têm uma aplicação e a palavra-chave padrão no início da assinatura do método. Além disso, pode-se definir métodos estáticos em interfaces. Novos e aprimorados APIs que se aproveitam de expressões lambda e dos {\it streams} em Java 8 descrevem as classes novos e aprimorados que se aproveitam de expressões lambda e {\it streams}. Aprimoramento do compilador Java aproveita digitação alvo para inferir os parâmetros de tipo de um método de invocação genérica. O tipo de destino de uma expressão é o tipo de dados que o compilador Java espera, dependendo de onde a expressão aparece, por exemplo, pode-se usar o tipo de destino de uma instrução de atribuição para o tipo de inferência em Java 7. No entanto, em Java 8, você pode usar o tipo de destino para a inferência de tipos em mais contextos. Anotações sobre tipos Java onde é possível aplicar uma anotação em qualquer lugar onde um tipo é usado, utilizado em um conjunto com um sistema de tipo de conector, isso permite a verificação de tipo mais forte de seu código e repetição de anotações que agora é possível aplicar o mesmo tipo de anotação mais de uma vez para a mesma declaração ou o tipo de utilização.






\section{Software Language Engineering}\label{sec:softEng}

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/stagesLanguageApp}
	\label{fig:stagesLanguageApp}
	\caption{Fases de aplicações com linguagens.}
\end{figure}

A manipulação de qualquer linguagem de programação é uma tarefa desafiadora e complicada de tal forma que o cenário para estes aplicativos podem ser a manipulação de um \texttt{XML}, automatizar a transformação dos dados de um banco de dados antigo para um mais atual, efetuar a importação de usuário de uma antiga versão ou até mesmo de um produto concorrente dentre outros softwares que manipulam uma linguagem.

Tendo em vista a complexidade envolvida é necessário dividir este trabalho de manipulação de uma linguagem em componentes que quando combinados proporcionam um programa capaz de realizar a tarefa desejada com a linguagem trabalhada. A Figura:~\ref{fig:stagesLanguageApp} exibe as divisões ocorridas para trabalha uma linguagem onde fica claro o \textit{pipeline} para a manipulação da entrada onde cada estágio tem como entrada a saída do estágio anterior.

Existe um esforço considerável para tratar a engenharia de linguagens de programação como sendo o desenvolvimento de um software comum. Algumas aplicações típicas deste domínio são \texttt{reconhecedor, interpretador, tradutor, gerador} conforme menciona Terrance Parr em~\cite{Parr:2009:LIP:1823613},  além de \texttt{ferramentas reconhecedoras de bugs}. Uma dessas é a ferramenta \textit{FindBugs}~\cite{FindBugs} que faz uso de alguns estágios descritos por Terance Parr em ~\cite{Parr:2009:LIP:1823613} para encontrar possíveis falhas em um programa que utilize a linguagem Java.

A combinação de algumas das ferramentas citadas anteriormente, originou o \textit{FindBugs}~\cite{FindBugs} que é uma ferramenta desenvolvida em Java que processa o \texttt{bytecode} para identificar padrões de erros. A Figura:~\ref{fig:findBugs} demonstra no mais alto nível a junção das ferramentas que o compõe. 

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/pipelineFindbugs}
	\label{fig:findBugs}
	\caption{Fase do pipiline do FindBugs.}
\end{figure}

\texttt{Reconhecedor:} É uma construção capaz de receber uma estrutura de dado como um input ou um fluxo de inputs. O fluxo de input pode geralmente é texto puro mas pode ser utilizado dado binário. Como exemplo de aplicação tem-se ferramentas analisadoras de referências cruzadas, e ferramentas para carregar classes.

\texttt{Interpretador:} Um interpretador, lê uma entrada, decodifica e executa as instruções, interpretadores variam de simples calculadoras até a implementação de linguagens de programação como Java, Python e PHP.

\texttt{Tradutor:}A partir um input de texto ou binário é emitido uma saída para uma linguagem que pode ser a mesma ou não. É a combinação do \textit{reader} e \textit{generator}. Como exemplo tem-se tradutores de linguagens extintas para linguagens atuais, \texttt{refactorers},  gerador de logs e macro pre-processadores.
	
\texttt{Gerador:} Percorre uma estrutura de dado e emite uma saída. Como exemplo tem-se ferramentas de mapeamento de objetos relacionais em banco de dados, serializador de objetos, gerador de código fonte e geradores de página web.



Especificamente no caso deste trabalho é necessário a construção de um software que realiza análise estática de código para identificar o uso e oportunidades do uso construções da linguagem Java. E para isso a Figura:~\ref{fig:stagesAnalyzer} exemplifica no alto nível as ferramentas que compõem o analisador.

\begin{figure}[h]
	\center
	\includegraphics[scale=0.9]{Imagens/stagesAnalizer}
	\label{fig:stagesAnalyzer}
	\caption{Ferramentas necessárias para construção do analisador estático.}
\end{figure}


Pode-se compreender este analisador como um {\it grammarware} pois é um software que depende de gramática para seu funcionamento neste caso a gramática da linguagem Java, pois estes softwares possuem conhecimentos essenciais da  gramática que manipulam. Como exemplos de arquiteturas que possuem tal conhecimento tem-se os programas de conversão de dados, processadores de \texttt{XML} e os que efetuam \textit{parses}.

Alguns cenários favorecem o desenvolvimento de softwares {\it grammarware}, onde dentre os diversos cenários pode-se destacar uma aplicação que necessite importar perfis de usuários para promover a transição da versão antiga para uma versão nova. Esta transição deve ser robusta e provavelmente necessitará de adptação deverá passar por um parser para que as partes que necessitem de adaptação possam ser identificadas.

Um outro cenário real é desenvolvimento de aplicações de banco de dados onde é necessário adotar uma nova linguagem de definição para um ambiente específico. De forma que automatizar esta solução requer o uso de um parser o qual será responsável por identificar os inputs de entrada para efetuar o mapeamento correto para a saída desejada no formato correto.



%Atualmente a evolução de uma linguagem de programação ocorre predominantemente de forma {\it ad-hoc} e em muitos casos manualmente, para a tradução de aplicativos legados, conforme a demanda. A ferramentas de análise para gerar a evolução necessária, {\it grammarware}, tende a condizir este processo abordando a classe gramatical que deve ser evoluída. Neste caso analisador que muitas vezes realizaria o trabalho por tentativa e erro, tem como base a gramática do código a ser analisado. Especificações do analisador são derivados automaticamente da semi gramática. Diferentes tecnologias de análise que podem ser orientadas em oposição a uma tecnologia específica. Assim o processo de personalização/evolução é susceptível de exigir a entrada de um engenheiro de {\it grammarware} o qual tem conhecimento prévio da gramática a ser analisada.

%Um ponto crítico quanto a análise de código fonte é o \textit{parser} da linguagem, onde é necessário reconhecer uma frase para efetuar a interpretação ou fazer a tradução para que a criação da representação intermediária aconteça. Inicialmente é necessário identificar se a frase que será tratada é um \textit{assignment} ou uma chamada de função.
 
%Reconhecer uma frase acarreta em duas coisas, distingui-la de outras construções e identificar os elementos e as subestruturas que compõem esta frase. Por exemplo se uma frase for reconhecida como um \textit{assignment}, pode-se identificar as variáveis a esquerda do operador \texttt{=} e uma expressão que é a subestrutura a direita. Este ato de reconhecer uma frase é denominado \textit{Parse}.

\section{Parse}

Confome introduzido anteriormente a concepção de uma ferramenta de análise de código faz-se necessário trabalhar com  \textit{parser} do código fonte o que torna isto uma tarefa complexa e desafiadora. Entretanto existem alguns padrões adotados para este contexto e com isso este trabalho abordará os quatro conceitos  mais importantes segundo Terence Parr em \cite{Parr:2009:LIP:1823613} para prover o parser de acordo com a necessidade.
\begin{itemize}
	\item \textbf{Mapping Grammars to Recursive-Descent Recognizers}\\
	Sua proposta é traduzir uma gramática para uma recursão descendente para reconhecer frases e sentenças em uma linguagem especificada por uma gramática. Este padrão identifica o núcleo do fluxo de controle para qualquer recursão descendente e é utilizado nos 3 padrões seguintes. 
	Para construir um reconhecedor léxico ou \textit{parsers} manualmente o melhor ponto de início é a gramática, com isso este padrão fornece uma maneira simples de construir reconhecedores diretamente de sua gramática.
	
	\item \textbf{LL(1) Recursive-Descent Lexer}\\
	O objetivo deste padrão é para emitir uma sequência de símbolos. Cada símbolo tem dois atributos primários: um tipo de \textit{token}(símbolo da categoria) e o texto associado por exemplo 
	no português, temos categorias como verbos e substantivos, bem como símbolos de pontuação, como vírgulas e pontos. Todas as palavras dentro de uma determinada categoria são do mesmo tipo de \textit{token}, embora o texto associado seja diferente. O tipo de nome do \textit{token} representa o categoria identificador. Então precisamos tipos de \textit{token} para o vocabulário \textit{string} fixa símbolos como também lidar com espaços em branco e comentários.
	\item \textbf{LL(1) Recursive-Descent Parser}\\
	Esse é o mais conhecido padrão de análise descendente recursiva. Ele só precisa	a olhar para o símbolo de entrada atual para tomar decisões de análise. Para cada regra de gramática, existe um método de análise no analisador. Este padrão analisa a estrutura sintática da sequência sinal de uma frase usando um único \textit{token} \textit{lookahead}. Este analisador pertence à LL(1) classe do analisador de cima para baixo, em especial, porque usa um único sinal de verificação à frente (daí o "1" no nome). É o principal mecanismo de todos os padrões de análise subsequentes. Este padrão mostra como implementar as decisões de análise que utilizam um símbolo único da visão antecipada. É a forma mais fraca de descendente recursivo parser, mas o mais fácil de compreender e aplicar.
	\item \textbf{LL(k) Recursive-Descent Parser}\\
	Este padrão utiliza a o modo \textit{top-down} para percorrer um árvore semântica com o auxílio de expressões booleanas que ajudam na tomada de decisão e estas expressões são conhecidas como predicados semânticos.
	
\end{itemize}

\input{capitulos/AnaliseEstatica}
%\input{capitulos/AnaliseLexica}
