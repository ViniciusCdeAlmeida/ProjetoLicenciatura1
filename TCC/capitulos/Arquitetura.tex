\chapter{Suporte Ferramental}


A Figura:~\ref{fig:Arquitetura} apresenta uma vis\~{a}o abstrata dos elementos que comp\~{o}em o 
analisador est\'{a}tico desenvolvido durante a condu\c c\~{a}o deste trabalho de gradua\c c\~{a}o. Em linhas 
gerais, tal suporte ferramental recupera do sistema de arquivos todos os arquivos contendo código fonte 
escrito na linguagem Java, {\color{red}reliza} o \textit{parse} desses arquivos gerando uma representação 
intermediária correspondente, mais adequada para as an\'{a}lises de interesse deste projeto, 
aplica uma série de mecanismos de análise estática para coletar as informações sobre o uso das 
caracter\'{i}sticas da linguagem de programa\c c\~{a}o e, por fim, gera os resultados no formato 
apropriado para as an\'{a}lises estat\'{i}sticas (no contexto deste projeto, foi feita a op\c c\~{a}o pelo 
formato CVS).

Atualmente existem diversas tecnologias capazes de prover ferramentas para implementar um analisador estático 
conforme as nossas necessidades. Entretanto, devido a maior experiência dos participantes do projeto com uso da linguagem Java, 
foi feita a op\c c\~{a}o por se utilizar a infraestrutura da plataforma \textit{Eclipse Java Development Tools}~\cite{EclipseJDT} 
(Eclipse JDT). O EclipseJDT~\cite{EclipseJDT} fornece um conjunto de ferramentas que auxiliam na constru\c c\~{a}o 
de ferramentas que permitem processar c\'{o}digo fonte escrito na linguagem de programa\c c\~{a}o Java. 

A plataforma Eclipse JDT é composta por 4 componentes principais \textit{APT, Core, Debug} e \textit{UI}. Neste projeto a 
plataforma foi usada essencialmente através do \textit{JDT Core}, que dispõe de uma representa\c c\~{a}o Java para a navega\c c\~{a}o 
e manipula\c c\~{a}o dos elementos de uma árvore sintática~\acs{AST} gerada a partir do c\'{o}digo fonte, onde os elementos 
da representa\c c\~{a}o correspondem aos elementeos sint\'{a}ticos da linguagem (como pacotes, classes, interfaces métodos e atributos). 

A~\acs{AST} provida pelo JDT é composta por 122 classes, como por exemplo existem 22 classe para representar senten\c cas  
como \textit{IF-Than-Else, Switch, While, BreakStatement} entre outras. Exitem 5 classes que trabalham exclusivamente com métodos referenciados 
e 6 classes exclusiva que tratam os tipos declarados como classes, interfaces e enumera\c c\~{o}es em Java.

O Eclipse JDT~\cite{EclipseJDT} disponibiliza ainda um \textit{Parser} para a linguagem Java que atende a especifica\c c\~{a}o 
Java 8 da linguagem (a mais atual com lan\c camento p\'{u}blico) e que produz a representação intermediária baseada no conjunto de classes Java 
mencionado anteriormente e que correspondem a uma~\acs{AST} do código fonte. A plataforma tamb\'{e}m oferece uma hierarquia de classes 
para traversia na AST, de acordo com o padr\~{a}o de projeto \textit{Visitors}~\cite{Gamma:1995}, e que facilita a análise estática 
de código fonte.

O padr\~{a}o de projeto \textit{Visitor}~\cite{Gamma:1995} \'{e} um padrão de projeto de característica comportamental que representa 
uma operação a ser realizada sobre elementos de uma \'{a}rvore de objetos. Neste caso a operação a ser realizadas é visitar nós de interesse da AST Java 
(como os n\'{o}s que representam o uso de uma express\~{a}o Lambda em Java). Cada \textit{visitor} permite que uma nova operação seja criada 
sem que a estrutura da \'{a}rvore de objetos sofra alterações. Com isso é trivial adicionar novas funcionalidades em um \textit{visitor} existente ou criar um novo.

Por outro lado, a biblioteca Eclipse JDT não fornece mecanismos para extração e exporta\c c\~{a}o de dados. Entretanto, no contexto 
deste projeto, foi implementado um conjunto de classes 
que visam obter maior facilidade e flexibilidade na exporta\c c\~{a}o das informa\c c\~{o}es coletadas durante a traversia nos n\'{o}s das 
ASTs. Essa flexibilidade foi alcançada com a utilização de introspecção de código que em Java é conhecido como \textit{reflection}. O 
restante dessa se\c c\~{a}o apresenta mais detalhes sobre a arquitetura e implementa\c c\~{a}o do analisador est\'{a}tico. 

\begin{figure}[tb]
	\center
	\includegraphics[scale=0.55]{Imagens/Arquitetura}
	\label{fig:Arquitetura}
	\caption{Alto nível de funcionamento do analisador estático.}
\end{figure}


\section{Entrada de dados}


O analisador estático recebe como entrada um arquivo \acs{CSV} (comma-separated values) que contém informa\c c\~{o}es sobre 
os projetos a serem analisados, como nome do projeto, caminho absoluto para uma entrada no sistema 
de arquivos com o c\'{o}digo fonte do projeto e a quantidade de linhas de código previamente 
computadas (conforme ilustrado na Figura:~\ref{fig:InputArquitetura}). As informações contidas no arquivo \acs{CSV} s\~{a}o processadas 
por um conjunto de classes utilitária que varrem os diretórios de um determinado projeto e seleciona todos os arquivos fonte da linguagem Java. Os códigos fontes Java encontrados servem ent\~{a}o como a entrada descrita na representa\c c\~{a}o abstrata 
do analisador est\'{a}tico (Figura:~\ref{fig:Arquitetura}). Ou seja, para cada projeto é feita uma varredura dos arquivos contendo 
c\'{o}digo fonte Java, que s\~{a}o convertidos para uma representa\c c\~{a}o intermedi\'{a}ria (por meio de 
um parser existente); processados e analisados com uma infra-estrutura de \emph{visitors}, e os resultados das an\'{a}lises s\~{a}o por fim exportados.

\begin{figure}[h]
	\center
	\includegraphics[scale=0.53]{Imagens/InputArquitetura}
	\label{fig:InputArquitetura}
	\caption{Input analisador estático.}
\end{figure}

\section{Análise da Representa\c c\~{a}o Intermedi\'{a}ria}

Após todos os código fontes Java identificado é dado início a verificação destes arquivos onde são processados e gerado um \textit{parser} para que os \textit{visitors} pesquisam padrões previamente estabelecidos onde a pesquisa elaborada com o principal objetivo de reconhecer elementos e sua subestruturas contidos no código fonte.
Com isso a representação intermediária deste analisador é o processamento do código fonte para converte-lo em um \textit{parser} para que os  \textit{visitor} realizem sua pesquisa. A Figura:~\ref{fig:FuncionamentoAnalisador} demonstra o mais alto nível do funcionamento deste projeto.

\begin{figure}[h]
	\center
	\includegraphics[scale=0.5]{Imagens/FuncionamentoVisitor}
	\label{fig:FuncionamentoAnalisador}
	\caption{Funcionamento analisador estático.}
\end{figure}

{\color{red}{\bf rbonifacio}parece que ocorre uma transi\c c\~{a}o muito abrupta de uma discussao alto nivel 
para uma discussao muito rica em detalhes.}

De forma mais técnica, a representa\c c\~{a}o intermedi\'{a}ria, para cada arquivo fonte o analisador
est\'{a}tico realiza a coleta de dados utilizando uma infraestrutura de \textit{visitors}. No contexto deste projeto, 
e objetivando um maior grau de reuso,
todo \emph{visitor} precisa herdar de uma classe abstrata e parametrizada em rela\c c\~{a}o a um tipo \textbf{T}, a classe \textbf{\textit{Visitor<T>}}, 
onde o tipo \textbf{T} deve corresponder a classe usada para armazenar as informações coletadas pelo \emph{visitor}, 
conforme o diagrama da Figura:~\ref{fig:DiagramaVisitor} {\color{red}n\~{a}o sei se esse diagrama 
representa corretamente o uso de visitors}. O parâmetro de tipo \textbf{T} faz referência a uma 
classe composta basicamente por atributos e por opera\c c\~{o}es de acesso (\textit{getters} e \textit{setters}), que serve para representar os dados extraídos. 
{\color{red}Em geral, de acordo com a arquitetura do analisador est\'{a}tico proposto, para cada constru\c c\~{a}o que se 
deseja identificar o perfil de ado\c c\~{a}o nos projetos, s\~{a}o criadas duas classes: uma classe (\texttt{public class C\{ \ldots \}}) 
para representar as informa\c c\~{o}es de interesse associadas ao uso de uma constru\c c\~{a}o particular da 
linguagem Java e uma classe (\texttt{public class ConstVisitor extends Visitor<C> \{ \ldots \}}) que \emph{visita} 
a constru\c c\~{a}o de interesse na \'{a}rvore sint\'{a}tica abstrata.} 

Por exemplo, a Listagem~\ref{lst:enum} apresenta 
o c\'{o}digo necess\'{a}rio para visitar e popular informa\c c\~{o}es relacionadas a declara\c c\~{a}o de 
enumera\c c\~{o}es. A classe \texttt{public class Visitor<T> \{ \ldots \}} possui uma cole\c c\~{a}o 
de objetos do tipo parametrizado, sendo poss\'{i}vel adicionar inst\^{a}ncias desses objetos com a chamada 
\texttt{collectedData.addValue()}. Note que o exemplo apresentado corresponde a um dos mais simples 
\emph{visitors} implementados. Outros \emph{visitors} possuem uma l\'{o}gica mais elaborada, como por exemplo os 
\emph{visitors} que identificam oportunidades para usar constru\c c\~{o}es como \emph{multi-catch} ou \emph{lambda 
expressions}. 

\begin{lstlisting}[caption={Classes usadas para capturar declara\c c\~{a}o de enumera\c c\~{o}es.}\label{lst:enum},language=Java] 
public class EnumDeclaration {
  private String file;
  private int startLine;
  private int endLine;
	
  //constructos + getters and setters.
}

public class EnumDeclarationVisitor extends Visitor<EnumDeclaration> {

  @Override
  public boolean visit(org.eclipse.jdt.core.dom.EnumDeclaration node) {
    
    EnumDeclaration dec = new EnumDeclaration(this.file, unit.getLineNumber(node.getStartPosition()), unit.getLineNumber(node.getLength() - node.getStartPosition()));
		
    collectedData.addValue(dec);

    return true;
  }

}


\end{lstlisting}



Confome exemplificado na Figura:~\ref*{fig:DiagramaVisitor}, com a necessidade de criar um \textit{Visitor} que detecte e colete informações dos tipos declarados no sistema, basta criar uma classes modelo \textit{TypeDeclaration.java} e  setar o parâmetro \textbf{<T>} como \textit{<TypeDeclaration>}, com isso os dados serão extraídas pelo \textit{Visitor, TypeDeclarationVisitor.java}, que identifica as informações pertinentes. {\color{red}refletir se esse par\'{a}grafo eh necessario}

A Tabela:~\ref{tab:VisitorsCriados} exibe todos os \textit{Visitors} criados neste projeto com sua respectiva descrição. {\color{red}importante incluir mais 
informa\c c\~{o}es aqui, como complexidade ciclom\'{a}tica e linhas de c\'{o}digo fonte de cada visitor}. 

\begin{table}[ht!] \footnotesize
	\centering
	\caption{Tabela de Visitors criados com suas respectivas atribuições}
	\label{tab:VisitorsCriados}	
    \begin{tabular}{ >{\arraybackslash}p{2.5in} | >{\arraybackslash}m{3.5in} }
%		\begin{tabular}{M|p{9cm}}% centered column
			\hline 
			\textbf{Visitor} & \textbf{Atribuição}\\ \hline \hline
			
			AICVisitor & Pesquisar \textit{Anonymous Inner Class} declaradas.\\ \hline
			
			EnumDeclarationVisitor 	& Pesquisa por \textit{Enums} declarados.\\ \hline
			
			ExistPatternVisitor	& Pesquisa \textit{EnhancedFor} que iteram sobre uma coleção procurando qualquer ocorrência nessa coleção.\\ \hline
			
			FieldAndVariableDeclarationVisitor & Lista todos as variáveis declaradas como os respectivos tipos.\\ \hline
			
			FilterPatternVisitor &  Lista todos os \textit{EnhancedFor} que iteram uma coleção filtrando elementos desta mesma coleção.\\ \hline
			
			ImportDeclarationVisitor & Lista todos os \textit{imports}.\\ \hline
			
			LambdaExpressionVisitor & Pesquisa casos de utilização da expressões lambda. \\ \hline
			
			LockVisitor & Verifica se nos métodos declarados existe alguma variável chamada Lock, ReentrantLock, ReadLock ou WriteLock. \\ \hline
			
			MapPatternVisitor & Pesquisa \textit{EnhancedFor} que iteram sobre uma coleção onde seja aplicado algum método sobre os itens desta coleção. \\ \hline
			
			MethodCallVisitor & Verifica onde esta sendo utilizado reflection no projeto.\\ \hline
			
			MethodDeclarationVisitor & Coleta informações sobre os métodos declarados nos projetos. \\ \hline
			
			ScriptingEngineVisitor & Verifica se o projeto faz chamada a algum \textit{Scripting}.\\ \hline
			
			SwitchStatementVisitor & Pesquisa \textit{Switchs} que utilizam \textit{String} como parâmetro.\\ \hline
			
			SwitchStringOpportunitiesVisitor &  Pesquisa \textit{If-Else} aninhados onde no \textit{If} contenha \textit{String}, caracterizando uma possibilidade de adoção de \textit{Switch} com \textit{String}.\\ \hline
		
			TryStatementVisitor & Pesquisa \textit{trys} que utilizar \textit{resource}, adoção de \textit{multicatch} e \textit{trys} que possuem \textit{catchs} aninhados.\\ \hline
			
			TypeDeclarationVisitor & Pesquisa todos os tipos declarados.\\ \hline 		
		\end{tabular}
\end{table}

% \section{Exporta\c c\~{a}o dos dados}

%% Para exportar os dados coletadas, foi constru\'{i}da uma solu\c c\~{a}o extens\'{i}vel, baseada no padr\~{a}o 
%% \emph{Inje\c c\~{a}o de Depend\^{e}ncia} e introspec\c c\~{a}o de c\'{o}digo. 
%% %\subsection{Injeçao de Dependência}


Para tornar a solu\c c\~{a}o mais extens\'{i}vel, foram utilizados os mecanismos de 
\emph{Inje\c c\~{a}o de Depend\^{e}ncia} e introspec\c c\~{a}o de c\'{o}digo. 
Injeção de dependência \acs{DI}, \'{e} um mecanismo de extensibilidade mais 
conhecido como um padr\~{a}o de projeto originalmente denominado de inversão de controle \acs{IoC}. 
De acordo com esse mecanismo, a sequência de criação dos objetos depende de como os mesmos são 
solicitados pelo sistema. Ou seja, quando um sistema é iniciado, 
os objetos necess\'{a}rios são instanciados e injetados de forma apropriada, 
geralmente de acordo com arquivo de configura\c c\~{o}es.

O mecanismo de inje\c c\~{a}o de depend\^{e}ncia foi incorporado na arquitetura 
com o uso do \textit{framework} Spring~\cite{SPRING_REF}, o que n\~{a}o causou 
nenhum impacto significativo na solu\c c\~{a}o inicialmente proposta e que n\~{a}o 
fazia uso de tal mecanismo--- os \emph{visitors} eram instanciados de maneira 
\emph{program\'{a}tica}. O uso do mecanismo de inje\c c\~{a}o de depend\^{e}ncia 
serviu para flexibilizar n\~{a}o apenas a incorpora\c c\~{a}o de novos \emph{visitors}, 
mas tamb\'{e}m para definir, de forma mais flex\'{i}vel, a estrat\'{e}gia de exporta\c c\~{a}o dos dados 
coletados. Gra\c cas ao mecanismo de inje\c c\~{a}o de depend\^{e}ncia, o desenvolvedor pode 
concentrar seu esforço na criação de \textit{visitors}, fazendo como que estes implementem a 
l\'{o}gica necess\'{a}ria para extrair as informações. Para que novos \emph{visitors} se conectem 
a plataforma, tornou-se necess\'{a}rio declarar o \textit{visitor} no arquivo com a defini\c c\~{a}o 
dos objetos gerenciados pelo Spring~\cite{SPRING_REF}.


\subsection{Exporta\c c\~{a}o dos Dados}

Na vers\~{a}o atual do suporte ferramental desenvolvido nessa monografia, os dados 
coletados pelo analisador est\'{a}tico s\~{a}o exportados exclusivamente no formato 
CSV. Esse formato facilita as an\'{a}lises estat\'{i}sticas usando o ambiente e linguagem 
de programa\c c\~{a}o R~\cite{R}. Também com foco na extensibilidade do sistema, os componentes envolvidos na 
geração de relatórios utilizam os mecanismos de inje\c c\~{a}o de depend\^{e}ncia, mencionado na 
se\c c\~{a}o anterior, e introspec\c c\~{a}o de c\'{o}digo, via a a API \textit{Reflection} da linguagem de 
programa\c c\~{a}o Java. Tal mecanismo oferece aos programadores a capacidade de escreverem componentes 
que podem observar e até modificar a estrutura e o comportamento dos objetos em tempo de execução.

A geração dos relatórios ocorre utilizando a classe \texttt{public class CSVData<T> \{ \ldots \ \}} onde o 
tipo parametrizado \textbf{<T>} é o mesmo utilizado para representar os dados coletados pelos \textit{visitors}. 
Os dados são obtidos através dos métodos de acesso (\textit{getters}) destas classes e exportados para arquivos~\acs{CSV}. 
%Na classe \texttt{CSVData} nesta classe também existe a injeção de dependência que é somente o cabeçalho do 
%arquivo ~\acs{CSV} o qual é declarado no \textit{beans.xml} ao mesmo tempo em que o \textit{Visitor} é 
% declarado, a Figura:~\ref{fig:DiagramaCSVData} exibe o diagrama de classe.

% O cabeçalho de cada \acs{CSV} é injetado pelo Spring no atributo \textbf{head:String[]}. Logo em seguida 
O método \textit{export()} da classe \textbf{CSVData<T>} descobre quais dados s\~{a}o armazenados nos objetos do 
tipo \textbf{<T>}, usando o mecanismo de introspec\c c\~{a}o de c\'{o}digo. Com isso, \'{e} poss\'{i}vel 
generalizar a implementa\c c\~{a}o e simplificar a exporta\c c\~{a}o de dados coletados a partir de 
\textit{visitors} espec\'{i}ficos. Ou seja, após a descoberta dos dados coletados pelos \textit{visitors} usando 
introspec\c c\~{a}o, \'{e} poss\'{i}vel recuperar os mesmos assumindo a exist\^{e}ncia de m\'{e}todos de 
acesso (\textit{getters} de acordo com a especifica\c c\~{a}o Java Beans) e, como isso, export\'{a}-los em arquivos \acs{CSV} de saída. 
A Listagem:~\ref{lst:reflection} demonstra o uso desse mecanismo para generalizar a exporta\c c\~{a}o dos 
dados. 

\begin{lstlisting}[caption={Reflection na geração de relatório.}\label{lst:reflection},language=Java] 
public class CSVData<T> implements Data<T>{
	...
	@Override
	public void export() {
		try (FileWriter writer = 
			new FileWriter(this.makeCsv(head), true)){
		
			StringBuffer str = new StringBuffer("");

			if(data == null) { return;	}
			
			for(T value : data) {
				//reflection code...
				for(Field f: value.getClass().getDeclaredFields()){
										
					String fieldName = f.getName();
					String prefix = "get";
					
					if(f.getType().isPrimitive() &&
						f.getType().equals(Boolean.TYPE)) {
						prefix = "is";
					}
					
					String methodName = prefix +
					 	Character.toUpperCase(fieldName.charAt(0)) +
					 	fieldName.substring(1);
										
					try {
						Method m = value.getClass().getDeclaredMethod(methodName);						
						str.append(m.invoke(value));
						str.append(";");
					}catch(NoSuchMethodException |  IllegalAccessException | 
						   IllegalArgumentException | InvocationTargetException e) {
						throw new RuntimeException("Type " + 
											value.getClass().getName() +
											" must have a method named " + methodName);
					}
				}
				writer.append(str.toString());
				writer.append("\n");
				
			}
			writer.flush();

		}catch(Exception e) {
			e.printStackTrace();
		}
	}
}
\end{lstlisting}


%Projetar um analisador estático para extrair informações de softwares desenvolvido não é uma simples tarefa, entretanto EclipseJDT~\cite{EclipseJDT} prove uma abstração significativa tornado menos árdua este projeto. O que pode possibilitar projetar uma arquitetura mais robusta para este analisador onde o foco de qualquer desenvolvedor que deseje utilizá-lo concentre-se apenas na produção de seus \textit{Visitors}. 
%
%Um ponto de extrema relevância foi tornar este analisador independente de qualquer plataforma e \acs{IDE} foi um ponto vital para o concepção deste projeto que não tem como intuito ser plugin de qualquer \acs{IDE} o que acarretaria na limitação do seu uso a um cenário específico mas sim uma ferramenta para apoiar no desenvolvimento de um software com construções atuais. Utilizando a portabilidade nativa entre as plataformas provido pela linguagem Java este trabalho foi concebido com intuito de atender ao mais diversos desenvolvedores quer utilizem Linux, Windows, Mac ou qualquer outro sistema operacional que tenha suporte para Java.
%
%A análise tem como início a seleção de projetos, nesse caso seleção em repositórios públicos, onde após o download é informado analisador o diretório raiz onde estes estão localizados. Após é iniciado uma listagem dos arquivos fonte Java contidos nos projeto e contabilizados o total de \acs{LOC} e criado uma árvore sintática para cada arquivo encontrado através de um \textit{parser} provido pela biblioteca EclipseJDT~\cite{EclipseJDT}. Em seguida os \textit{Visitors} são instanciados com o objetivo de percorrer os nós destas árvores para pesquisar por construções de código previamente determinadas.
%
%Todas as construções pesquisadas quando encontradas pelos \textit{Visitors} são armazenadas temporariamente enquanto o analisador verifica todo projeto, quando é verificado a última árvore sintática pelos \textit{Visitors} é iniciado o processo de exportar os dados encontrados para um arquivo \acs{CSV} o conteúdo relevante destes blocos, a Figura:~\ref{fig:Arquitetura} demostra de maneira clara o funcionamento do analisador. Após a exportação dos dados o analisador inicia todo processo novamente caso exista mais de um projeto.
%
%Devido ao mecanismo de \textit{reflection} proveniente da linguagem Java, o desenvolvedor não tem a necessidade de implementar código para exportação de dados tendo em vista que isto ocorre automaticamente através da introspecção realizada pelo analisador extraindo os dados armazenados pelos \textit{Visitors}.

%	\begin{figure}[h]
%		\center
%		\includegraphics[scale=0.52]{Imagens/Arquitetura}
%		\label{fig:Arquitetura}
%		\caption{Funcionamento analisador estático.}
%	\end{figure}


%\section{Arquitetura}
%
%\subsection{Visitors}
%
%
%
%\begin{lstlisting}
%package br.unb.cic.sa.visitors;
%
%import org.eclipse.jdt.core.dom.ASTVisitor;
%import org.eclipse.jdt.core.dom.CompilationUnit;
%import br.unb.cic.sa.model.Data;
%
%public class Visitor<T> extends ASTVisitor implements IVisitor<T> {
%	protected CompilationUnit unit;
%	protected Data<T> collectedData;
%	protected String file;
%	
%	public Visitor() {}
%	
%	@Override
%	public void setUnit(CompilationUnit unit) { this.unit = unit; }
%	
%	@Override
%	public void setCollectedData(Data<T> colletion) { this.collectedData = colletion; }
%	
%	@Override
%	public void setFile(String file) {	this.file = file; }
%
%	@Override
%	public Data<T> getCollectedData() {	return collectedData;	}	
%}
%\end{lstlisting}
%
%
%A tabela:~\ref{tab:VisitorsCriados} detalha os 17 \textit{Visitors} criados com a respectiva descrição do trabalho realizado. Como forma de exemplificar a criação de um \textit{Visitors}, etapa a qual é composta de 4 passos quo serão demonstrados a seguir.
%
%A investigação para saber como o tratamento de exceção Java tem sido utilizado acarretou na criação de um \textit{Visitor} específico para este fim, \textit{TryStatementVisitor}, responsável por pesquisar este mecanismo o qual pode contar com alguma evoluções ao logo do histórico da linguagem Java. A pesquisa é iniciada encontrando blocos \textit{trys/catch}, onde destes será coletadas as informações referentes a adoção de \textit{resources} e oportunidade de utilizar \textit{multicatch} em blocos \textit{trys} que contenham \textit{catchs} iguais aninhados.
%%, neste caso de oportunidades os \textit{catchs} são testados por igualdade mas é trivial a utilização de um algoritmo mais avançado que teste a similaridade.
%
%Criação do \textit{Visitor TryStatementVisitor} com exemplo.
%
%	\begin{enumerate}
%		\item Inicialmente é necessário criar a classe modelo onde esta terá atribuição de receber os dados que serão extraídos pelos \textit{Visitors}, basicamente as classes modelos são compostas de \textit{getters} e \textit{setters} e são declaradas no pacote  \textit{\textbf{br.unb.cic.sa.model}}.
%			\begin{lstlisting}
%package br.unb.cic.sa.model;
%
%public class TryStatementData  {
%	private String file;
%	private int startLine;
%	private int endLine;
%	private boolean tryWithResource = false;
%	private boolean multiCatch = false;
%	
%	public TryStatementData(String file, int startLine, int endLine){
%		this.file = file;
%		this.startLine = startLine;
%		this.endLine = endLine;
%	}
%	
%	//getters and setters
%}
%			\end{lstlisting}
%			
%			
%		\item Em seguida, é concebida a criação do \textit{Visitor} no pacote \textit{\textbf{br.unb.cic.sa.visitors}} onde esta nova classe será estendida da classe parametrizada \textit{\textbf{Visitor<TryStatementData>}} apresentada anteriormente onde a parametrização desta classe é o modelo criado anteriormente.
%			
%			\begin{lstlisting}
%package br.unb.cic.sa.visitors;
%
%import java.util.List;
%import org.eclipse.jdt.core.dom.CatchClause;
%import org.eclipse.jdt.core.dom.TryStatement;
%import br.unb.cic.sa.model.TryStatementData;
%import br.unb.cic.sa.similarity.BasicSimilarityChecker;
%import br.unb.cic.sa.similarity.SimilarityChecker;
%
%public class TryStatementVisitor extends Visitor<TryStatementData> {
%
%	SimilarityChecker similarity;
%
%	public TryStatementVisitor() {
%		similarity = new BasicSimilarityChecker();
%	}
%
%	@Override
%	public boolean visit(s node) {
%
%		TryStatementData t = new TryStatementData(this.file, unit.getLineNumber(node.getStartPosition()),
%				unit.getLineNumber(node.getStartPosition() + node.getLength()));
%		
%		if (node.resources().size() > 0) {
%			t.setTryWithResource(true);
%		}
%	
%		if (node.catchClauses().size() > 1) {
%			if (this.checkSimilarity(node.catchClauses())) {
%				t.setMultiCatch(true);
%			}
%		}
%
%		this.collectedData.addValue(t);
%
%		return super.visit(node);
%	}
%	
%	private boolean checkSimilarity(List<CatchClause> catchClause) {
%		for (CatchClause cc : catchClause) {
%			for (CatchClause cn : catchClause) {
%				// To ignore the same catch in loops
%				if (!cc.equals(cn)) {
%				
%				//Chamada externa para testar similaridade
%					if (this.similarity.checkSimilarity(cc.getBody(),
%														cn.getBody())) {
%						return true;
%					}
%				}
%			}
%		}
%		return false;
%	}
%
%}
%			\end{lstlisting}
%			
%		 Na linha24, é testada a condição para saber se este bloco fez adoção de \textit{Resouce}. Na linha 30 é verificado que o bloco é um possível caso de \textit{multicatch} pois existe mais de um bloco. Na linha 39 tem-se o método \textit{checkSimilarity} o qual efetua a comparação dos blocos \textit{Catch} aninhados, entretando de forma trivial na linha 46, pode ser utilizado um algoritmo mais sofisticado para testar por similaridade modificando apenas o conteúdo do método \textbf{\textit{checkSimilarity}} da classe \textit{\textbf{SimilarityChecker}} o que não resulta em mudanças neste \textit{Visitor}.
%		
%	
%			\item Em seguida deve-se declarar o cabeçalho no arquivo \textit{resource/Beans.xml} do \textit{Spring} que estará presente no \acs{CSV} de saída. Onde este cabeçalho é composto pelo dados que serão extraídos pelos \textit{Visitors} e armazenados no modelo criado.
%			
%			\begin{lstlisting}
%<bean id="tryStatementData" class="br.unb.cic.sa.model.CSVData">
%	<property name="outDir" value="output"/>
%	<property name="fileName" value="tryStatement"/>
%	<property name="head" value="typeProject, before, project, version, file, start, end, resource, multiCatch"/> 
%</bean>
%			\end{lstlisting}
%			
%			
%			\item Por fim declarar o \textit{Visitor} como um \textit{bean} do \textit{Spring} para que este seja injetado no projeto e assim realize sua pesquisa.
%			
%			\begin{lstlisting}
%<bean id="tryStatementVisitor" class="br.unb.cic.sa.visitors.TryStatementVisitor">
%	<property name="collectedData" ref="tryStatementData"/>
%</bean>
%			\end{lstlisting}
%			
%	\end{enumerate}
%
%
%
%\subsection{Exportar Dados}
%A exportação dos dados para \acs{CSV} é realizado de forma automática utilizando o mecanismo de \textit{reflection} fornecido por Java. A classe parametrizada \textbf{\textit{CSVData<T>}} no pacote \textbf{\textit{br.unb.cic.sa.model}} implementa a interface \textit{\textbf{Data<T>}} onde \textbf{\textit{<T>}} faz  aos modelos declarados para as informações coletadas.
%
%\begin{lstlisting}
%package br.unb.cic.sa.model;
%
%public interface Data<T> {
%	public void setProject(Project project);
%	public void addValue(T value);
%	public void export();
%	public int size();
%	public void clean();
%}
%\end{lstlisting}
%
%
%Onde o atributo \textit{String[] head} é injetado pelo \textit{Spring} pois fora declarado anteriormente na criação do visitor. O método \textbf\textit{{export()}}, na linha 23, é o método responsável para exportar os dados em seus respectivos \acs{CSV} pois este método recupera as informações contidas nas coleções populadas pelos \textit{Visitors} e com \textit{reflection} captura os campos declarados em especial para os métodos quais são pré-fixados com \textit{get ou is} que terão seus valores capturados para que sejam exportados.
%
%\begin{lstlisting}
%package br.unb.cic.sa.model;
%
%import java.io.File;
%import java.io.FileWriter;
%import java.io.IOException;
%import java.lang.reflect.Field;
%import java.lang.reflect.InvocationTargetException;
%import java.lang.reflect.Method;
%import java.util.ArrayList;
%import java.util.List;
%
%public class CSVData<T> implements Data<T>{
%
%	private Project project;
%	private String fileName;
%	private String outDir;
%	private String[] head; 
%	private List<T> data;
%
%	...
%	
%	@Override
%	public void export() {
%		
%		try (FileWriter writer = new FileWriter(this.makeCsv(head), true)){
%		
%			StringBuffer str = new StringBuffer("");
%
%			if(data == null) {
%				return;
%			}
%			
%			for(T value : data) {
%				str = new StringBuffer("");
%				
%				str.append(project.getTypeOfProject());
%				str.append(";");
%				str.append(project.getBefore());
%				str.append(";");
%				str.append(project.getProjectName());
%				str.append(";");
%				str.append(project.getProjectRevision());
%				str.append(";");
%			
%				for(Field f: value.getClass().getDeclaredFields()){
%										
%					String fieldName = f.getName();
%					String prefix = "get";
%					
%					if(f.getType().isPrimitive() &&
%					   f.getType().equals(Boolean.TYPE)) {
%						prefix = "is";
%					}
%					
%					String methodName = prefix + 
%								Character.toUpperCase(fieldName.charAt(0)) +
%								fieldName.substring(1);
%										
%					try {
%						Method m = value.getClass().getDeclaredMethod(methodName);						
%						str.append(m.invoke(value));
%						str.append(";");
%					}catch(
%							NoSuchMethodException | 
%							IllegalAccessException |
%							IllegalArgumentException |
%							InvocationTargetException e) {
%							
%						throw new RuntimeException("Type " + 
%											value.getClass().getName() +
%											" must have a method named " +
%											 methodName);
%					}
%				}
%				
%				writer.append(str.toString());
%				writer.append("\n");
%				
%			}
%		
%			writer.flush();
%		
%		}
%		catch(Exception e) {
%			e.printStackTrace();
%		}
%	}
%}
%
%\end{lstlisting}
