\chapter{Analisador Estático e Caracterização do Uso de Construções da Linguagem Java}\label{cap:arquiteruta}

Com o intuito de obter uma compreensão sobre o uso 
das construções da linguagem Java, tornou-se 
necessária a implementação de uma ferramenta 
de análise estática de propósito bem 
específico, por outro lado com capacidade de 
ser extensível para extrair diferentes tipos de 
informações. Utilizando esse suporte ferramental, 
descrito na Seção~\ref{sec:ferramenta}, foi conduzido 
um estudo empírico para caracterizar o uso de 
construções da linguagem Java, cujos resultados 
estão descritos na Seção~\ref{sec:resultados}.

\section{Analisador Estático}\label{sec:ferramenta}

A Figura~\ref{fig:Arquitetura} apresenta 
uma visão geral dos elementos que compõem o 
analisador estático desenvolvido durante a condução 
deste trabalho de graduação. Em linhas 
gerais, tal suporte ferramental recupera do sistema 
de arquivos todos os arquivos contendo código fonte 
escrito na linguagem Java, realiza o \textit{parse} 
desses arquivos gerando uma representação 
intermediária correspondente, mais adequada para 
as análises de interesse deste projeto, 
aplica uma série de mecanismos de análise estática 
para coletar as informações sobre o uso das 
características da linguagem de programação e, por fim, 
gera os resultados no formato 
apropriado para as análises estatísticas 
no contexto deste projeto, foi feita a opção pelo 
formato \acs{CSV}.

Atualmente existem diversas ferramentas e bibliotecas 
de programação que auxiliam a construção
de analisadores estáticos,  
conforme as nossas necessidades.
Entretanto, devido a maior experiência dos 
participantes do projeto com uso da linguagem Java, 
foi feita a opção por se utilizar a 
infraestrutura da plataforma \textit{Eclipse Java Development Tools}~\cite{EclipseJDT} 
(Eclipse JDT). O Eclipse JDT 
fornece um conjunto de ferramentas que auxiliam na construção 
de ferramentas que permitem processar código fonte escrito 
na linguagem de programação Java. 
A plataforma Eclipse JDT é composta por 4 componentes principais: 
APT, \textit{Core}, \textit{Debug} e UI~\cite{EclipseJDT}. Neste projeto a 
plataforma foi usada essencialmente através do \textit{JDT Core}, 
que dispõe de uma representação Java 
para a navegação 
e manipulação dos elementos de uma árvore 
sintática \acs{AST} gerada a partir do código fonte, onde os elementos 
da representação correspondem às construções 
sintáticas da linguagem (como pacotes, classes, interfaces métodos e atributos). 

A~\acs{AST} provida pelo \acs{JDT} que é composta por 122 classes, 
como, por exemplo, existem 22 classe para representar sentenças  
como \textit{IF-Then-Else, Switch, While, BreakStatement} 
entre outras. Existem cinco classes que trabalham exclusivamente com métodos referenciados 
e seis classes exclusivas que tratam os tipos declarados, como classes, interfaces 
e enumerações em Java.
O Eclipse JDT~\cite{EclipseJDT} disponibiliza ainda um \textit{parser} 
para a linguagem Java que atende a especificação 
Java 8 da linguagem e que produz a representação intermediária baseada no conjunto de classes Java 
mencionado anteriormente e que corresponde 
a uma~\acs{AST} do código fonte. A plataforma também oferece 
uma hierarquia de classes 
para travessia na \acs{AST}, de acordo com o padrão de projeto \textit{Visitor}~\cite{Gamma:1995}, e 
que facilita a análise estática 
de código fonte.

O padrão de projeto \textit{Visitor}~\cite{Gamma:1995} é um 
padrão de projeto de característica comportamental que representa 
uma operação a ser realizada sobre elementos de uma árvore de objetos. 
Neste caso, a operação a ser realizadas é visitar nós de interesse da \acs{AST} Java 
(como os nós que representam o uso de uma expressão Lambda em Java). 
Cada \textit{visitor} permite que uma nova operação seja criada 
sem que a estrutura da árvore de objetos sofra alterações, de modo que tornou-se relativamente  
simples adicionar novas funcionalidades em um \textit{visitor} existente ou criar um novo \textit{visitor}.
Por outro lado, a biblioteca Eclipse JDT não fornece mecanismos para 
extração e exportação de dados. Entretanto, no contexto 
deste projeto, foi implementado um conjunto de classes 
que visam obter maior facilidade e flexibilidade na exportação das 
informações coletadas durante a travessia nos nós das 
ASTs. Essa flexibilidade foi alcançada com a utilização de introspecção de 
código, que em Java é conhecido como \textit{reflection}. As 
próximas seções 3.1.1, 3.1.2 e 3.1.3 apresentam mais detalhes sobre a arquitetura e 
implementação do analisador estático, descrevendo 
as principais decisões de projeto relacionadas às cinco 
fases do analisador estático. 

\begin{figure}[tb]
	\center
	\includegraphics[scale=0.55]{Imagens/Arquitetura}
	\label{fig:Arquitetura}
	\caption{Visão geral da arquitetura do analisador estático}
\end{figure}


\subsection{Entrada do Analisador Estático}

O analisador estático recebe como entrada um arquivo \acs{CSV} 
(\emph{comma-separated values}) 
que contém informações sobre 
os projetos a serem analisados, como nome do projeto, 
caminho absoluto para uma pasta no sistema 
de arquivos contendo o código fonte do projeto e a quantidade de linhas de código previamente 
computadas (conforme ilustrado na Figura~\ref{fig:Arquitetura}). 
As informações contidas no arquivo \acs{CSV} são processadas 
por um conjunto de classes utilitárias que percorrem os diretórios 
de um determinado projeto e seleciona todos os arquivos fonte da linguagem Java. 
Os arquivos contendo código fonte Java servem então como a entrada 
descrita na representação abstrata 
do analisador estático como descrito na Figura~\ref{fig:Arquitetura}. Ou seja, para cada 
projeto são recuperados os arquivos contendo 
código fonte Java, que são convertidos para uma 
representação intermediária (por meio de 
um parser existente); processados e analisados com 
uma infraestrutura de \emph{visitors}, e os resultados das análises são, por fim, 
exportados.

Conforme mencionado, essa fase do analisador estático realiza o processamento 
de cada arquivo Java dos projetos analisados. Sob a perspectiva de usabilidade, 
o usuário deve executar o programa principal informando, na linha de 
comando, o caminho para o arquivo \acs{CSV} contendo as definições dos 
projetos. Isso produz uma lista contendo todos os projetos a serem processados 
(ver Linha 25 no Listing:~\ref{lst:programaPrincipal}). Após a lista de 
projetos ter sido carregada, cada projeto é analisado com o uso 
da classe \texttt{ProjectAnalyser}, que possui um método 
(\texttt{analyse}) com a lógica necessária para 
processar a base de código fonte de cada projeto. A Figura~\ref{fig:metodoAnalyse} 
apresenta a implementação do método \texttt{analyse}, que 
recebe como parâmetro um projeto. Note na linha seis da 
Figura~\ref{fig:metodoAnalyse} que o resultado do \textit{parse} 
em um arquivo fonte produz uma instância da classe 
\texttt{CompilationUnit} que pertence a plataforma 
Eclipse JDT e que representa a AST de um determinado 
arquivo Java. Essa classe possui um método \texttt{accept}, 
conforme o padrão de projeto \textit{visitor}, que é usado 
para pela ferramenta de análise estática para 
coletar as informações do uso de construções 
Java por meio de uma análise da representação 
intermediária. Isso é feito considerando cada um dos 
\emph{visitors} aplicados em uma análise específica. 
  
\begin{figure}[ht]
\begin{lstlisting}[numbers=left,   numberstyle=\tiny]
public class Main {
  public static void main(String[] args) {
    String pathCsv = ``''; 
    
    if(args.length == 1) {
      System.out.println(``Args: ''+ args[0].toString());
      pathCsv = args[0];
    }else {
      System.out.println(``Error: inform a valid csv file!!!\nEXIT'');
      System.exit(0);
    }
    
    ReadCsv rcsv = new ReadCsv(pathCsv);
    
    List<String> errors = rcsv.getError();
    
    errors.forEach(e -> System.out.println(``Error in '' + e));
 
    ApplicationContext ctx = CDI.Instance().getContextCdi(); 
    
    ProjectAnalyser pa = ctx.getBean(``pa'', ProjectAnalyser.class);
    
    List<Project> projects = rcsv.readInput();
    
    try {
      projects.stream().forEach(project -> pa.analyse(project));
    }catch(Exception t) {
      t.printStackTrace();
    }  
  }
}
\end{lstlisting}
  \caption{Classe que representa o programa principal do analisador estático}
  \label{lst:programaPrincipal}
\end{figure}


\begin{figure}[ht]
\begin{lstlisting}[language=Java]
public void analyse(Project p)  {
  CompilationUnit compilationUnit = null;
  List<String> fs = IO.list(p.getPath(), new String[] { ``java'' });
    
  for (String file : fs) {
    compilationUnit = Parser.Instance().parse(new File(file));
    
    for(IVisitor visitor : listVisitors){
      visitor.getCollectedData().setProject(p);
      visitor.setFile(file);
      visitor.setUnit(compilationUnit);
        
      compilationUnit.accept((ASTVisitor) visitor);
    }
  }    
  exportData();    
}
\end{lstlisting}
 \label{fig:metodoAnalyse}
 \caption{Implementação do método \texttt{analyse}, na classe \texttt{ProjectAnalyser}.}
\end{figure}

%% \begin{figure}[h]
%% 	\center
%% 	\includegraphics[scale=0.53]{Imagens/InputArquitetura}
%% 	\label{fig:InputArquitetura}
%% 	\caption{Input analisador estático.}
%% \end{figure}


\subsection{Análise da Representação Intermediária}

Conforme mencionado na seção anterior, o resultado do 
\textit{parser} em um arquivo fonte produz uma instância 
da classe \texttt{CompilationUnit}, que corresponde a 
uma \acs{AST} com todas as definições de tipo e 
implementação de comportamento presentes em um módulo 
Java. A plataforma Eclipse JDT oferece uma infraestrutura 
de classes para realizar a travessia em uma \acs{AST}, usando 
o padrão de projeto \textit{visitor}. Dessa forma, 
foi feita uma implementação de biblioteca de 
\textit{visitors}, para extrair as informações 
presentes na representação intermediária.   

%% Após todos os código fontes Java identificado é dado início a verificação destes arquivos onde são processados e gerado um \textit{parser} para que os \textit{visitors} pesquisam padrões previamente estabelecidos onde a pesquisa elaborada com o principal objetivo de reconhecer elementos e sua subestruturas contidos no código fonte.
%% Com isso a representação intermediária deste analisador é o processamento do código fonte para convertê-lo em um \textit{parser} para que os  \textit{visitor} realizem sua pesquisa. A Figura~\ref{fig:FuncionamentoAnalisador} demonstra o mais alto nível do funcionamento deste projeto.

%% \begin{figure}[h]
%% 	\center
%% 	\includegraphics[scale=0.5]{Imagens/FuncionamentoVisitor}
%% 	\label{fig:FuncionamentoAnalisador}
%% 	\caption{Funcionamento analisador estático.}
%% \end{figure}

%{\color{red}{\bf rbonifacio}parece que ocorre uma transição muito abrupta de uma discussão alto nivel para uma discussão muito rica em detalhes.}

% De forma mais técnica, a representação intermediária, para cada arquivo fonte o analisador
% estático realiza a coleta de dados utilizando uma infraestrutura de \textit{visitors}. 

No contexto deste projeto, 
e objetivando um maior grau de reuso, 
toda classe \emph{visitor} precisa herdar de uma classe abstrata e 
parametrizada em relação a um tipo \texttt{T}, 
a classe \texttt{Visitor<T>}, 
onde o tipo \texttt{T} deve corresponder a classe usada para armazenar 
as informações coletadas pelo \emph{visitor}. O parâmetro de tipo \texttt{T} 
faz referência a uma 
classe composta basicamente por atributos e por 
operações de acesso (\textit{getters} e \textit{setters}), 
que serve para representar os dados extraídos. 
Em geral, de acordo com a arquitetura do analisador estático proposto, 
para cada construção que se 
deseja identificar o perfil de adoção nos projetos, são criadas 
duas classes: uma classe (\texttt{public class C\{ \ldots \}}) 
que representar as informações de interesse 
associadas ao uso de uma construção da 
linguagem Java e uma classe (\texttt{public class CVisitor extends Visitor<C> \{ \ldots \}}) 
que \emph{visita} a construção de interesse na árvore sintática abstrata. 
Por exemplo, a Figura~\ref{fig:enum} apresenta 
o código necessário para visitar e popular informações relacionadas a declaração de 
enumerações. A classe \texttt{public class Visitor<T> \{ \ldots \}} possui uma coleção 
de objetos do tipo parametrizado, sendo possível adicionar instâncias desses objetos com a chamada 
\texttt{collectedData.addValue()}. Note que o exemplo apresentado corresponde a um dos mais simples 
\emph{visitors} implementados. Outros \emph{visitors} possuem uma lógica mais elaborada, como por exemplo os 
\emph{visitors} que identificam oportunidades para usar construções 
como \emph{multi-catch} ou \emph{lambda expressions}. 

\begin{figure}[htb]
\begin{lstlisting}
public class EnumDeclaration {
  private String file;
  private int startLine;
  private int endLine;
	
  //constructor + getters and setters.
}

public class EnumDeclarationVisitor extends Visitor<EnumDeclaration> {

  @Override
  public boolean visit(org.eclipse.jdt.core.dom.EnumDeclaration node) {
    
    EnumDeclaration dec = new EnumDeclaration(...);
		
    collectedData.addValue(dec);

    return true;
  }

}
\end{lstlisting}
\label{fig:enum}
\caption{Classes usadas para capturar declarações de enumerações.}
\end{figure}


%% O diagrama da Figura~\ref*{fig:DiagramaVisitor} 
%% exibe de maneira técnica o procedimento de criar um \textit{Visitor} que detecte e colete informações dos tipos declarados no sistema, basta criar uma classes modelo \textit{TypeDeclaration.java} e  setar o parâmetro \textbf{<T>} como \textit{<TypeDeclaration>}, com isso os dados serão extraídas pelo \textit{Visitor, TypeDeclarationVisitor.java}, que identifica as informações pertinentes. {\color{red}refletir se esse parágrafo eh necessário}

%% \begin{figure}[h]
%% 	\center
%% 	\includegraphics[scale=0.25]{Imagens/diagramaVisitor}
%% 	\label{fig:DiagramaVisitor}
%% 	\caption{Funcionamento analisador estático.}
%% \end{figure}

\subsubsection{Descrição dos Visitors}
Os \textit{visitors} implementados neste projeto 
são brevemente descritos a seguir, enquanto que 
a Tabela~\ref{tab:VisitorsCriados} apresenta 
duas métricas relacionadas à complexidade 
de implementação, em termos de 
complexidade ciclomática e total de linhas de código fonte. 
A complexidade ciclomática é dada pela quantidade de caminhos independentes 
em um trecho de código, enquanto que a quantidade de linhas de código 
foi computada ignorando comentários e linhas em branco.  Vale 
ressaltar que a complexidade ciclomática 
dos \textit{visitors} varia entre um e oito  (com a média igual a 2.5). A 
quantidade média de linhas de código necessária para escrever um 
\textit{visitor} é 47.

\begin{itemize}
\item \texttt{AIC:} Coleta informações relacionadas a declaração de 
\textit{Anonymous Inner Classes}. Tal informação é útil 
para estimar oportunidades de uso de expressões lambda. 

\item \texttt{ExistPattern:} Coleta informações de laços \texttt{foreach} 
que iteram sobre uma coleção com o intuito de verificar se um 
determinado objeto está presente na coleção. Tal informação é útil 
para estimar oportunidades de uso de expressões lambda. 


\item \texttt{FieldAndVariableDeclaration:} Coleta informações relacionadas 
a declarações de atributos e variáveis, com o intuito de 
extrair informações sobre a adoção de Java Generics. 

\item \texttt{FilterPattern:} Coleta informações de laços \texttt{foreach} 
que iteram sobre uma coleção com o intuito de 
filtrar elementos presentes na coleção. Tal informação é útil
para estimar oportunidades de uso de expressões lambda. 

\item \texttt{ImportDeclaration:} Coleta informações relacionadas à
importação de bibliotecas, sendo útil para estimar a adoção 
de bibliotecas voltadas para programação concorrente ou integração 
com linguagens de \textit{scripting}, por exemplo. 

\item \texttt{LambdaExpression:} Coleta informações relacionadas à 
adoção de expressões lambda. 

\item \texttt{Lock:} Verifica se os métodos utilizam algum dos mecanismos 
de \emph{lock} suportados diretamente pela linguagem Java, como \texttt{Lock}, 
\texttt{ReentrantLock}, \texttt{ReadLock} ou \texttt{WriteLock}.

\item \texttt{MapPattern:} Coleta informações de laços \texttt{foreach} 
que iteram sobre uma coleção com o intuito de 
aplicar alguma operação sobre os elementos presentes na coleção. 
Tal informação é útil 
para estimar oportunidades de uso de expressões lambda. 

\item \texttt{MethodCall:} Coleta informações relacionadas às 
chamadas de método, sendo \'{u}til para estimar o uso da API de 
introspecção de código, por exemplo. 

\item \texttt{MethodDeclaration:} Coleta informações relacionadas 
às declarações de métodos, sendo útil para identificar 
padrões de uso de Java Generics, por exemplo.

\item \texttt{ScriptEngine:} Coleta informações relacionadas 
ao uso da API Java para integração com linguagens de \textit{scripting}.  

\item \texttt{SwitchStatement:} Coleta informações relacionadas 
ao uso de sentenças \texttt{switch-case}, com o intuito principal 
de identificar o uso de \texttt{strings} nesse tipo de sentença. 

\item \texttt{SwitchString:} Coleta informações associadas às 
oportunidades de reestruturação de código para usar 
sentenças \texttt{switch-case} com \texttt{strings}. 

\item \texttt{TryStatement:} Coleta informações relacionadas 
ao uso de blocos \texttt{try-catch}, em particular para estimar o 
uso da construção \texttt{try-with-resources}. 

\item \texttt{TypeDeclaration:} Coleta informações sobre 
os tipos declarados (classes, interfaces, enumerações), com 
o intuito, por exemplo, de estimar a adoção de Java Generics. 
\end{itemize}

\begin{table}[ht] \footnotesize
	\centering
	\caption{Estimativa da complexidade de desenvolvimento de cada \emph{visitor}.}
	\label{tab:VisitorsCriados}	
    \begin{tabular}{crr}
%		\begin{tabular}{M|p{9cm}}% centered column
			\hline 
			Visitor &  \acs{CC} & \acs{LoC}\\ \hline \hline
			
			\texttt{AIC} & 6 & 64\\ 
			
			\texttt{ExistPattern}  & 28 & 116\\ 
			
			\texttt{FieldAndVariableDeclaration} & 8 & 81\\ 
			
			\texttt{FilterPattern}  & 43 & 168\\ 
			
			\texttt{ImportDeclaration}& 1 & 63\\ 
			
			\texttt{LambdaExpression} & 1 & 33\\ 
			
			\texttt{Lock} & 12 & 75\\ 
			
			\texttt{MapPattern} & 27 & 103\\ 
			
			\texttt{MethodCall} & 2 & 22\\ 
			
			\texttt{MethodDeclaration} & 5 & 45\\ 
			
			\texttt{ScriptingEngine} & 5 & 39\\ 
			
			\texttt{SwitchStatement} & 3 & 35\\ 
			
			\texttt{SwitchStringOpportunities} & 3 & 50\\ 
		
			\texttt{TryStatement} & 11 & 80\\ 
			
			\texttt{TypeDeclaration} & 2 & 41\\ \hline
		\end{tabular}
\end{table}

% \section{Exportação dos dados}

%% Para exportar os dados coletadas, foi construída uma solução extensível, baseada no padrão 
%% \emph{Injeção de Dependência} e introspecção de código. 
%% %\subsection{Injeçao de Dependência}


\subsubsection{Extensibilidade para Inclusão de Novos Visitors}

Para tornar a solução mais extensível, foram utilizados os mecanismos de 
\emph{Injeção de Dependência} e introspecção de código. 
Injeção de dependência (\emph{Dependency Injection}, \acs{DI}), 
é um mecanismo de extensibilidade mais 
conhecido como um padrão de projeto originalmente denominado de inversão de controle (\emph{Inversion of Control}, \acs{IoC}). 
De acordo com esse mecanismo, a sequência de criação dos objetos depende de como os mesmos são 
solicitados pelo sistema. Ou seja, quando um sistema é iniciado, 
os objetos necessários são instanciados e injetados de forma apropriada, 
geralmente de acordo com arquivo de configurações.
O mecanismo de injeção de dependência foi incorporado na arquitetura 
com o uso do \textit{framework} Spring~\cite{SPRING_REF}, o que não causou 
nenhum impacto significativo na solução inicialmente proposta e que não 
fazia uso de tal mecanismo--- nesse caso, os \emph{visitors} eram instanciados de maneira 
\emph{programática}. O uso do mecanismo de injeção de dependência 
serviu para flexibilizar não apenas a incorporação de novos \emph{visitors}, 
mas também para definir, de forma mais flexível, a estratégia de exportação dos dados 
coletados. Graças ao mecanismo de injeção de dependência, o desenvolvedor pode 
concentrar seu esforço na criação de \textit{visitors}, fazendo como que estes implementem a 
lógica necessária para extrair as informações. Para que novos \emph{visitors} se conectem 
à plataforma, tornou-se necessário declarar o \textit{visitor} no arquivo com a definição 
dos objetos gerenciados pelo Spring~\cite{SPRING_REF}.


\subsection{Exportação dos Dados}

Na versão atual do suporte ferramental desenvolvido nessa monografia, os dados 
coletados pelo analisador estático são exportados exclusivamente no formato 
\acs{CSV}. Esse formato facilita as análises estatísticas usando o ambiente e linguagem 
de programação R~\cite{R}. Também com foco na extensibilidade do sistema, os componentes envolvidos na 
geração de relatórios utilizam os mecanismos de injeção de dependência, mencionado na 
seção anterior, e introspecção de código, via \acs{API} \textit{Reflection} da linguagem de 
programação Java. Tal mecanismo oferece aos programadores a capacidade de escrever componentes 
que podem observar e até modificar a estrutura e o comportamento dos objetos em tempo de execução.

A geração dos relatórios utiliza a classe \texttt{public class CSVData<T> \{ \ldots \ \}} onde o 
tipo parametrizado \texttt{<T>} é o mesmo utilizado para representar 
os dados coletados pelos \textit{visitors}. 
Os dados são obtidos através dos métodos de acesso (\textit{getters}) destas 
classes e exportados para arquivos~\acs{CSV}. 
O método \textit{export()} da classe \textbf{CSVData<T>} descobre quais dados são armazenados nos objetos do 
tipo \textbf{<T>}, usando o mecanismo de introspecção de código. Com isso, é possível 
generalizar a implementação e simplificar a exportação de dados coletados a partir de 
\textit{visitors} específicos. Ou seja, após a descoberta dos dados coletados pelos \textit{visitors} usando 
introspecção, é possível recuperar os mesmos assumindo a existência de métodos de 
acesso (\textit{getters} de acordo com a especificação Java Beans) e, 
como isso, exportá-los em arquivos \acs{CSV} de saída. 
A Figura~\ref{fig:exportacao} apresenta o uso desse mecanismo para generalizar a exportação dos 
dados. 

\begin{figure}[ht]
\begin{lstlisting}[language=Java]
public class CSVData<T> implements Data<T> {

  @Override
  public void export() {
    StringBuffer str = new StringBuffer("");
      
    if(data == null) { return; }
      
    for(T value : data) {
      //reflection code...
      for(Field f: value.getClass().getDeclaredFields()){
	  
	String fieldName = f.getName();
	String prefix = "get";
	  
	if(f.getType().isPrimitive() && f.getType().equals(Boolean.TYPE)) {
	  prefix = "is";
	}
					
	String methodName = prefix +
	Character.toUpperCase(fieldName.charAt(0)) +
	fieldName.substring(1);
	  
	Method m = value.getClass().getDeclaredMethod(methodName);						
	str.append(m.invoke(value));
	str.append(";");
	
	writer.append(str.toString());
	writer.append("\n");			
		
	writer.flush();  
      }
    }
  }
\end{lstlisting}
\label{fig:exportacao}
\caption{Exportação de dados usando o mecanismo de introspecção de código.}
\end{figure}

%Projetar um analisador estático para extrair informações de softwares desenvolvido não é uma simples tarefa, entretanto EclipseJDT~\cite{EclipseJDT} prove uma abstração significativa tornado menos árdua este projeto. O que pode possibilitar projetar uma arquitetura mais robusta para este analisador onde o foco de qualquer desenvolvedor que deseje utilizá-lo concentre-se apenas na produção de seus \textit{Visitors}. 
%
%Um ponto de extrema relevância foi tornar este analisador independente de qualquer plataforma e \acs{IDE} foi um ponto vital para o concepção deste projeto que não tem como intuito ser plugin de qualquer \acs{IDE} o que acarretaria na limitação do seu uso a um cenário específico mas sim uma ferramenta para apoiar no desenvolvimento de um software com construções atuais. Utilizando a portabilidade nativa entre as plataformas provido pela linguagem Java este trabalho foi concebido com intuito de atender ao mais diversos desenvolvedores quer utilizem Linux, Windows, Mac ou qualquer outro sistema operacional que tenha suporte para Java.
%
%A análise tem como início a seleção de projetos, nesse caso seleção em repositórios públicos, onde após o download é informado analisador o diretório raiz onde estes estão localizados. Após é iniciado uma listagem dos arquivos fonte Java contidos nos projeto e contabilizados o total de \acs{LOC} e criado uma árvore sintática para cada arquivo encontrado através de um \textit{parser} provido pela biblioteca EclipseJDT~\cite{EclipseJDT}. Em seguida os \textit{Visitors} são instanciados com o objetivo de percorrer os nós destas árvores para pesquisar por construções de código previamente determinadas.
%
%Todas as construções pesquisadas quando encontradas pelos \textit{Visitors} são armazenadas temporariamente enquanto o analisador verifica todo projeto, quando é verificado a última árvore sintática pelos \textit{Visitors} é iniciado o processo de exportar os dados encontrados para um arquivo \acs{CSV} o conteúdo relevante destes blocos, a Figura~\ref{fig:Arquitetura} demostra de maneira clara o funcionamento do analisador. Após a exportação dos dados o analisador inicia todo processo novamente caso exista mais de um projeto.
%
%Devido ao mecanismo de \textit{reflection} proveniente da linguagem Java, o desenvolvedor não tem a necessidade de implementar código para exportação de dados tendo em vista que isto ocorre automaticamente através da introspecção realizada pelo analisador extraindo os dados armazenados pelos \textit{Visitors}.

%	\begin{figure}[h]
%		\center
%		\includegraphics[scale=0.52]{Imagens/Arquitetura}
%		\label{fig:Arquitetura}
%		\caption{Funcionamento analisador estático.}
%	\end{figure}


%\section{Arquitetura}
%
%\subsection{Visitors}
%
%
%
%\begin{lstlisting}
%package br.unb.cic.sa.visitors;
%
%import org.eclipse.jdt.core.dom.ASTVisitor;
%import org.eclipse.jdt.core.dom.CompilationUnit;
%import br.unb.cic.sa.model.Data;
%
%public class Visitor<T> extends ASTVisitor implements IVisitor<T> {
%	protected CompilationUnit unit;
%	protected Data<T> collectedData;
%	protected String file;
%	
%	public Visitor() {}
%	
%	@Override
%	public void setUnit(CompilationUnit unit) { this.unit = unit; }
%	
%	@Override
%	public void setCollectedData(Data<T> colletion) { this.collectedData = colletion; }
%	
%	@Override
%	public void setFile(String file) {	this.file = file; }
%
%	@Override
%	public Data<T> getCollectedData() {	return collectedData;	}	
%}
%\end{lstlisting}
%
%
%A tabela:~\ref{tab:VisitorsCriados} detalha os 17 \textit{Visitors} criados com a respectiva descrição do trabalho realizado. Como forma de exemplificar a criação de um \textit{Visitors}, etapa a qual é composta de 4 passos quo serão demonstrados a seguir.
%
%A investigação para saber como o tratamento de exceção Java tem sido utilizado acarretou na criação de um \textit{Visitor} específico para este fim, \textit{TryStatementVisitor}, responsável por pesquisar este mecanismo o qual pode contar com alguma evoluções ao logo do histórico da linguagem Java. A pesquisa é iniciada encontrando blocos \textit{trys/catch}, onde destes será coletadas as informações referentes a adoção de \textit{resources} e oportunidade de utilizar \textit{multicatch} em blocos \textit{trys} que contenham \textit{catchs} iguais aninhados.
%%, neste caso de oportunidades os \textit{catchs} são testados por igualdade mas é trivial a utilização de um algoritmo mais avançado que teste a similaridade.
%
%Criação do \textit{Visitor TryStatementVisitor} com exemplo.
%
%	\begin{enumerate}
%		\item Inicialmente é necessário criar a classe modelo onde esta terá atribuição de receber os dados que serão extraídos pelos \textit{Visitors}, basicamente as classes modelos são compostas de \textit{getters} e \textit{setters} e são declaradas no pacote  \textit{\textbf{br.unb.cic.sa.model}}.
%			\begin{lstlisting}
%package br.unb.cic.sa.model;
%
%public class TryStatementData  {
%	private String file;
%	private int startLine;
%	private int endLine;
%	private boolean tryWithResource = false;
%	private boolean multiCatch = false;
%	
%	public TryStatementData(String file, int startLine, int endLine){
%		this.file = file;
%		this.startLine = startLine;
%		this.endLine = endLine;
%	}
%	
%	//getters and setters
%}
%			\end{lstlisting}
%			
%			
%		\item Em seguida, é concebida a criação do \textit{Visitor} no pacote \textit{\textbf{br.unb.cic.sa.visitors}} onde esta nova classe será estendida da classe parametrizada \textit{\textbf{Visitor<TryStatementData>}} apresentada anteriormente onde a parametrização desta classe é o modelo criado anteriormente.
%			
%			\begin{lstlisting}
%package br.unb.cic.sa.visitors;
%
%import java.util.List;
%import org.eclipse.jdt.core.dom.CatchClause;
%import org.eclipse.jdt.core.dom.TryStatement;
%import br.unb.cic.sa.model.TryStatementData;
%import br.unb.cic.sa.similarity.BasicSimilarityChecker;
%import br.unb.cic.sa.similarity.SimilarityChecker;
%
%public class TryStatementVisitor extends Visitor<TryStatementData> {
%
%	SimilarityChecker similarity;
%
%	public TryStatementVisitor() {
%		similarity = new BasicSimilarityChecker();
%	}
%
%	@Override
%	public boolean visit(s node) {
%
%		TryStatementData t = new TryStatementData(this.file, unit.getLineNumber(node.getStartPosition()),
%				unit.getLineNumber(node.getStartPosition() + node.getLength()));
%		
%		if (node.resources().size() > 0) {
%			t.setTryWithResource(true);
%		}
%	
%		if (node.catchClauses().size() > 1) {
%			if (this.checkSimilarity(node.catchClauses())) {
%				t.setMultiCatch(true);
%			}
%		}
%
%		this.collectedData.addValue(t);
%
%		return super.visit(node);
%	}
%	
%	private boolean checkSimilarity(List<CatchClause> catchClause) {
%		for (CatchClause cc : catchClause) {
%			for (CatchClause cn : catchClause) {
%				// To ignore the same catch in loops
%				if (!cc.equals(cn)) {
%				
%				//Chamada externa para testar similaridade
%					if (this.similarity.checkSimilarity(cc.getBody(),
%														cn.getBody())) {
%						return true;
%					}
%				}
%			}
%		}
%		return false;
%	}
%
%}
%			\end{lstlisting}
%			
%		 Na linha24, é testada a condição para saber se este bloco fez adoção de \textit{Resouce}. Na linha 30 é verificado que o bloco é um possível caso de \textit{multicatch} pois existe mais de um bloco. Na linha 39 tem-se o método \textit{checkSimilarity} o qual efetua a comparação dos blocos \textit{Catch} aninhados, entretando de forma trivial na linha 46, pode ser utilizado um algoritmo mais sofisticado para testar por similaridade modificando apenas o conteúdo do método \textbf{\textit{checkSimilarity}} da classe \textit{\textbf{SimilarityChecker}} o que não resulta em mudanças neste \textit{Visitor}.
%		
%	
%			\item Em seguida deve-se declarar o cabeçalho no arquivo \textit{resource/Beans.xml} do \textit{Spring} que estará presente no \acs{CSV} de saída. Onde este cabeçalho é composto pelo dados que serão extraídos pelos \textit{Visitors} e armazenados no modelo criado.
%			
%			\begin{lstlisting}
%<bean id="tryStatementData" class="br.unb.cic.sa.model.CSVData">
%	<property name="outDir" value="output"/>
%	<property name="fileName" value="tryStatement"/>
%	<property name="head" value="typeProject, before, project, version, file, start, end, resource, multiCatch"/> 
%</bean>
%			\end{lstlisting}
%			
%			
%			\item Por fim declarar o \textit{Visitor} como um \textit{bean} do \textit{Spring} para que este seja injetado no projeto e assim realize sua pesquisa.
%			
%			\begin{lstlisting}
%<bean id="tryStatementVisitor" class="br.unb.cic.sa.visitors.TryStatementVisitor">
%	<property name="collectedData" ref="tryStatementData"/>
%</bean>
%			\end{lstlisting}
%			
%	\end{enumerate}
%
%
%
%\subsection{Exportar Dados}
%A exportação dos dados para \acs{CSV} é realizado de forma automática utilizando o mecanismo de \textit{reflection} fornecido por Java. A classe parametrizada \textbf{\textit{CSVData<T>}} no pacote \textbf{\textit{br.unb.cic.sa.model}} implementa a interface \textit{\textbf{Data<T>}} onde \textbf{\textit{<T>}} faz  aos modelos declarados para as informações coletadas.
%
%\begin{lstlisting}
%package br.unb.cic.sa.model;
%
%public interface Data<T> {
%	public void setProject(Project project);
%	public void addValue(T value);
%	public void export();
%	public int size();
%	public void clean();
%}
%\end{lstlisting}
%
%
%Onde o atributo \textit{String[] head} é injetado pelo \textit{Spring} pois fora declarado anteriormente na criação do visitor. O método \textbf\textit{{export()}}, na linha 23, é o método responsável para exportar os dados em seus respectivos \acs{CSV} pois este método recupera as informações contidas nas coleções populadas pelos \textit{Visitors} e com \textit{reflection} captura os campos declarados em especial para os métodos quais são pré-fixados com \textit{get ou is} que terão seus valores capturados para que sejam exportados.
%
%\begin{lstlisting}
%package br.unb.cic.sa.model;
%
%import java.io.File;
%import java.io.FileWriter;
%import java.io.IOException;
%import java.lang.reflect.Field;
%import java.lang.reflect.InvocationTargetException;
%import java.lang.reflect.Method;
%import java.util.ArrayList;
%import java.util.List;
%
%public class CSVData<T> implements Data<T>{
%
%	private Project project;
%	private String fileName;
%	private String outDir;
%	private String[] head; 
%	private List<T> data;
%
%	...
%	
%	@Override
%	public void export() {
%		
%		try (FileWriter writer = new FileWriter(this.makeCsv(head), true)){
%		
%			StringBuffer str = new StringBuffer("");
%
%			if(data == null) {
%				return;
%			}
%			
%			for(T value : data) {
%				str = new StringBuffer("");
%				
%				str.append(project.getTypeOfProject());
%				str.append(";");
%				str.append(project.getBefore());
%				str.append(";");
%				str.append(project.getProjectName());
%				str.append(";");
%				str.append(project.getProjectRevision());
%				str.append(";");
%			
%				for(Field f: value.getClass().getDeclaredFields()){
%										
%					String fieldName = f.getName();
%					String prefix = "get";
%					
%					if(f.getType().isPrimitive() &&
%					   f.getType().equals(Boolean.TYPE)) {
%						prefix = "is";
%					}
%					
%					String methodName = prefix + 
%								Character.toUpperCase(fieldName.charAt(0)) +
%								fieldName.substring(1);
%										
%					try {
%						Method m = value.getClass().getDeclaredMethod(methodName);						
%						str.append(m.invoke(value));
%						str.append(";");
%					}catch(
%							NoSuchMethodException | 
%							IllegalAccessException |
%							IllegalArgumentException |
%							InvocationTargetException e) {
%							
%						throw new RuntimeException("Type " + 
%											value.getClass().getName() +
%											" must have a method named " +
%											 methodName);
%					}
%				}
%				
%				writer.append(str.toString());
%				writer.append("\n");
%				
%			}
%		
%			writer.flush();
%		
%		}
%		catch(Exception e) {
%			e.printStackTrace();
%		}
%	}
%}
%
%\end{lstlisting}
