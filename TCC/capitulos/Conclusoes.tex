\chapter{Considerações Finais e Trabalhos Futuros}
Este c\'{a}pitulo tem o objetivo de destacar as principais caracter\'{i}sticas do analisador est\'{a}tico desenvolvido neste trabalho de conclus\~{a}o, al\'{e}m de destar alguns pontos relevantes para poss\'{i}veis abordagens em trabalhos futuros que adotem esta ferramenta como objeto para pesquisa.

\section{Considerações Finais}
Atualmente utilizar o analisador est\'{a}tico projetado ao longo deste trabalho de conclus\~{a}o \'{e} bem simples para o usu\'{a}rio final pois durante os est\'{a}gios de desenvolvimento sempre foi uma premissa ocultar a complexidade encontrada no desenvolvimento para simplificar a utiliza\c{c}\~{a}o da ferramenta. Para que qualquer desenvolvedor em qualquer grau de experi\^{e}cia tenha confian\c{c}a e seguran\c{c}a em adotar esta ferramenta.

Com foco em estender o projeto quer seja para analisar outras caracter\'{i}sticas Java quer seja para outras Linguagens este projeto com poucas modifica\c{c}\~{o}es pode estender-se a qualquer linguagem de programa\c{c}\~{a}o com facilidade, tudo isso devido ao mecanismo de Injeção de Dependência  que foi agregado. A flexibilidade na extra\c{c}\~{a}o dos dados deve-se a combina\c{c}\~{a}o dos mecanismos de Inje\c{c}\~{a}o e Introspec\c{c}\~{a}o onde facilmente pode ser modificado para que a atual de extra\c{c}\~{a}o em arquivos~\acs{CSV} possa persistir em um banco de dados, ou utilizar as duas abordagens em conjunto.

Atrav\'{e}s deste analisador foi poss\'{i}vel reafirmar a pesquisa que Parnin et al.~\cite{Parnin:ACM2011} realizou em \num{2011} ainda \'{e} atual pois n\~{a}o houve discrep\^{a}ncia nos dados encontrados por este trabalho. O que serviu como m\'{e}trica para comprovar a confiabilidade nos dados extra\'{i}dos por esta ferramenta. Por outro lado pode-se comprovar que existe oportunidades reais de \textit{refactoring} que s\~{a}o ignoradas como o mecanismo de exce\c{c}\~{a}o sem evolu\c{c}\~{a}o, oportunidades de emprego de express\~{o}es lambda e aplica\c{c}\~{a}o do \texttt{switch-string}.

Ap\'{o}s estas considera\c{c}\~{o}es pode-se afirmar que foi poss\'{i}vel obter \^{e}xito na proposta inicial deste trabalho que foi criar uma ferramenta flex\'{i}vel e extens\'{i}vel. Al\'{e}m  de possibilitar aprofundar o conhecimento na \'{a}rea de engenharia de \textit{software} com \^{e}nfase em linguagens de programa\c{c}\~{a}o e arquitetura de software. Visando sempre utilizar as ferramentas mais modernas durante o processo de desenvolvimento.



%Este trabalho de conclus\~{a}o concluiu com \^{e}xito o desenvolvimento do analisador est\'{a}tico proposto e este foi utilizado para comprovar a existência de uma grande quantidade  de código duplicado/obsoleto em projetos open-source. Atentando em descobrir o real motivo de tais contru\c{c}\~{o}es de c\'{o}digo, foi realizado contato via e-mail com algumas comunidades de desenvolvimento por\'{e}m somente duas responderam, \textit{Cassandra} e \textit{Maven}, onde pode ser constatado que os desenvolvedores preferem n\~{a}o adotar novas \textit{features} pois utilizam geralmente uma vers\~{a}o mais antiga da JDK relatado em: (http://goo.gl/h0uloY). A altera\c{c}\~{a}o/evolu\c{c}\~{a}o \'{e} realizada em \'{a}reas que s\~{a}o trabalhandas na no dia a dia e n\~{a}o reservando um tempo espec\'{i}fico para realizar uma evolu\c{c}\~{a}o isto foi relatado em: (http://goo.gl/GQ4Ckn). Pode-se concluir que a exist\^{e}ncia de c\'{o}digo duplicado \'{e} dada ao fato das equipes de desenvolvimento n\~{a}o adotarem uma \textit{feature} e ainda por n\~{a}o reservarem tempo para revisar e evoluir um c\'{o}digo desenvolvido anteriormente, sendo realizado apenas uma refatora\c{c}\~{a}o nas parte que consequentemente venham a ser retrabalhadas, isto pode ter como consequ\^{e}ncia direta techos de c\'{o}digo congelados.


\section{Trabalhos Futuros}
Do vasto conte\'{u}do que pode ser abordado ao ter como objeto de pesquisa uma linguagem de programa\c{c}\~{a}o,  esta se\c{c}\~{a}o tem a finalidade de enumerar algumas sugest\~{o}es relevantes para o enriquecimento deste trabalho.

\begin{enumerate}
	\item Estender a pesquisa a outras linguagens de programa\c{c}\~{a}o seria de extrema import\^{a}ncia para o estudo mais detalhado de um projetos pois \'{e} poss\'{i}vel encontrar projetos que utilizam mais de uma linguagem em constru\c{c}\~{a}o.

	\item A cria\c{c}\~{a}o de \texttt{Visitors} mais espec\'{i}ficos para extrair outras informa\c{c}\~{a}o quer seja da linguagem Java que seja de outra linguagem que este analisador venha a trabalhar no futuro.

	\item Pode-se tamb\'{e}m armazenar os dados extra\'{i}dos em um banco de dados e realizar um hist\'{o}rico de extra\c{c}\~{a}o para acompanhar de forma sistem\'{a}tica a evolu\c{c}\~{a}o e ado\c{c}\~{a}o de caracter\'{i}sticas da linguagem.

	\item Utilizar uma linguagem de dom\'{i}nio espec\'{i}fico de metaprograma\c{c}\~{a}o que analise o c\'{o}digo fonte e implemente \textit{refactoring}. Como sugest\~{a}o para linguagem de metaprograma\c{c}\~{a}o tem-se Racal-MPL que pode ser facilmente integrada a linguagem Java atrav\'{e}s da infraestrutura do Eclipse.

\end{enumerate}

%Como projeto futuro \'{e} proposto o aproveitamento da arquitetura atual para generalizar este analisador para  outras linguagens como \texttt{C++} em um primeiro momento. Ainda com intu\'{i}to de tornar automatizar a refatora\c{c}\~{a}o pode se acoplar uma linguagem de meta-programação, \texttt{Rascal MPL}, pois estas linguagens s\~{a}o adequadas para realizar o enriquecimento sem\^{a}ntico na realiza\c{c}\~{a}o da refatora\c{c}\~{a}o.

% Para o  linguagem Rascal MPL se destaca tendo em vista que é uma linguagem que atenderia perfeitamente esta evolução dada sua fácil integração com Java e por ser uma linguagem de meta-programação.

%E com isso torna-lo mais especialização deste trabalho para efetuar o \textit{refactoring} de maneira automática seria de grande importância na evolução de código congelado. Com os \textit{visitors} existentes é possível identificar oportunidades reais de empregar \textit{multi-catch} e \textit{swicht com String} o que seria uma evolução. 



%Existe também a possibilidade da extensão do analisador para identificar \textit{multicatch} por similaridade onde atualmente essa tarefa é realizada por igualdade. Com um algoritmo eficiente que detecte a similaridade com certeza a eficiência dessa \textit{feature} irá crescer consideravelmente o que acarretará em um \textit{refactoring} ainda mais significativo.Existe ainda a possibilidade de ampliar a pesquisa para encontrar objetos que contém método \textit{close} dentro de blocos \textit{Try's} o que acarretaria em um outro \textit{refactoring} visando migrar estes objetos para os \textit{resources} que estes pode receber.
%
%Existem diversas características evolutivas da linguagem \textit{Java} a serem atacados tais como \textit{boilerplate} e \textit{anonymousInnerClass} que podem ser tratados com \textit{LambdaExpression}. Um projeto futuro de grande valia seria a evolução desta ferramenta para que obter um \textit{refactoring} automático de códigos ultrapassados assim possibilitando a evolução natural de \textit{softwares} legados e \textit{opensource}.
%
%Como exemplo destes códigos temos o caso de \textit{EnhancedFor} que iteram sobre uma \textit{Collection} o que a evolução deste abre algumas possibilidade como a facilidade de aplicar concorrência na evolução com \textit{Lambda} o que atualmente é muito complicado adicionar concorrência em um loop.

