\chapter{Considerações Finais e Trabalhos Futuros}
Este capítulo tem o objetivo de destacar as principais características do analisador estático desenvolvido neste trabalho de conclusão, além de destacar alguns pontos relevantes para possíveis abordagens em trabalhos futuros que adotem esta ferramenta como objeto para pesquisa.

Conforme exemplificado nas Seções \ref{subsec:entradaAS}, \ref{subsec:classeModelos} e \ref{subsec:criacaoVisitors} fica simples de um desenvolvedor sem experiência nesse domínio criar um \texttt{Visitor} que pesquise por construções específicas. Destaca-se que é obrigatório seguir esse padrão para que sejam mapeadas características desejadas entretanto um dos objetivos era simplificar essa tarefa para desenvolvedores sem ou com pouco experiência.
 
\section{Considerações Finais}
Atualmente utilizar o analisador estático projetado ao longo deste trabalho de conclusão é bem simples para o usuário final pois durante os estágios de desenvolvimento sempre foi uma premissa ocultar a complexidade encontrada no desenvolvimento para simplificar a utilização da ferramenta. Para que qualquer desenvolvedor em qualquer grau de experiência tenha confiança e segurança em adotar esta ferramenta.

Com foco em estender o projeto quer seja para analisar outras características Java quer seja para outras Linguagens este projeto com poucas modificações pode estender-se a qualquer linguagem de programação com facilidade, tudo isso devido ao mecanismo de Injeção de Dependência  que foi agregado. A flexibilidade na extração dos dados deve-se a combinação dos mecanismos de Injeção e Introspecção onde facilmente pode ser modificado para que a atual de extração em arquivos~\acs{CSV} possa persistir em um banco de dados, ou utilizar as duas abordagens em conjunto.

Através deste analisador foi possível reafirmar a pesquisa que Parnin et al.~\cite{Parnin:ACM2011} realizou em \num{2011} ainda é atual pois não houve discrepância nos dados encontrados por este trabalho. O que serviu como métrica para comprovar a confiabilidade nos dados extraídos por esta ferramenta. Por outro lado pode-se comprovar que existe oportunidades reais de \textit{refactoring} que são ignoradas como o mecanismo de exceção sem evolução, oportunidades de emprego de expressões lambda e aplicação do \texttt{switch-string}.

Após estas considerações pode-se afirmar que foi possível obter êxito na proposta inicial deste trabalho que foi criar uma ferramenta flexível e extensível. Além de possibilitar aprofundar o conhecimento na área de engenharia de \textit{software} com ênfase em linguagens de programação e arquitetura de software. Visando sempre utilizar as ferramentas mais modernas durante o processo de desenvolvimento.



%Este trabalho de conclusão concluiu com \^{e}xito o desenvolvimento do analisador estático proposto e este foi utilizado para comprovar a existência de uma grande quantidade  de código duplicado/obsoleto em projetos open-source. Atentando em descobrir o real motivo de tais contruções de código, foi realizado contato via e-mail com algumas comunidades de desenvolvimento porém somente duas responderam, \textit{Cassandra} e \textit{Maven}, onde pode ser constatado que os desenvolvedores preferem não adotar novas \textit{features} pois utilizam geralmente uma versão mais antiga da JDK relatado em: (http://goo.gl/h0uloY). A alteração/evolução é realizada em áreas que são trabalhandas na no dia a dia e não reservando um tempo específico para realizar uma evolução isto foi relatado em: (http://goo.gl/GQ4Ckn). Pode-se concluir que a exist\^{e}ncia de código duplicado é dada ao fato das equipes de desenvolvimento não adotarem uma \textit{feature} e ainda por não reservarem tempo para revisar e evoluir um código desenvolvido anteriormente, sendo realizado apenas uma refatoração nas parte que consequentemente venham a ser retrabalhadas, isto pode ter como consequ\^{e}ncia direta techos de código congelados.


\section{Trabalhos Futuros}
Do vasto conteúdo que pode ser abordado ao ter como objeto de pesquisa uma linguagem de programação, esta seção tem a finalidade de enumerar algumas sugestões relevantes para o enriquecimento deste trabalho.

\begin{enumerate}
	\item Estender a pesquisa a outras linguagens de programação seria de extrema importância para o estudo mais detalhado de um projetos pois é possível encontrar projetos que utilizam mais de uma linguagem em construção.

	\item A criação de \texttt{Visitors} mais específicos para extrair outras informação quer seja da linguagem Java que seja de outra linguagem que este analisador venha a trabalhar no futuro.

	\item Pode-se também armazenar os dados extraídos em um banco de dados e realizar um histórico de extração para acompanhar de forma sistemática a evolução e adoção de características da linguagem.

	\item Utilizar uma linguagem de domínio específico de metaprogramação que analise o código fonte e implemente \textit{refactoring}. Como sugestão para linguagem de metaprogramação tem-se Racal-MPL que pode ser facilmente integrada a linguagem Java através da infraestrutura do Eclipse.

\end{enumerate}

%Como projeto futuro é proposto o aproveitamento da arquitetura atual para generalizar este analisador para  outras linguagens como \texttt{C++} em um primeiro momento. Ainda com intuíto de tornar automatizar a refatoração pode se acoplar uma linguagem de meta-programação, \texttt{Rascal MPL}, pois estas linguagens são adequadas para realizar o enriquecimento semântico na realização da refatoração.

% Para o  linguagem Rascal MPL se destaca tendo em vista que é uma linguagem que atenderia perfeitamente esta evolução dada sua fácil integração com Java e por ser uma linguagem de meta-programação.

%E com isso torna-lo mais especialização deste trabalho para efetuar o \textit{refactoring} de maneira automática seria de grande importância na evolução de código congelado. Com os \textit{visitors} existentes é possível identificar oportunidades reais de empregar \textit{multi-catch} e \textit{swicht com String} o que seria uma evolução. 



%Existe também a possibilidade da extensão do analisador para identificar \textit{multicatch} por similaridade onde atualmente essa tarefa é realizada por igualdade. Com um algoritmo eficiente que detecte a similaridade com certeza a eficiência dessa \textit{feature} irá crescer consideravelmente o que acarretará em um \textit{refactoring} ainda mais significativo.Existe ainda a possibilidade de ampliar a pesquisa para encontrar objetos que contém método \textit{close} dentro de blocos \textit{Try's} o que acarretaria em um outro \textit{refactoring} visando migrar estes objetos para os \textit{resources} que estes pode receber.
%
%Existem diversas características evolutivas da linguagem \textit{Java} a serem atacados tais como \textit{boilerplate} e \textit{anonymousInnerClass} que podem ser tratados com \textit{LambdaExpression}. Um projeto futuro de grande valia seria a evolução desta ferramenta para que obter um \textit{refactoring} automático de códigos ultrapassados assim possibilitando a evolução natural de \textit{softwares} legados e \textit{opensource}.
%
%Como exemplo destes códigos temos o caso de \textit{EnhancedFor} que iteram sobre uma \textit{Collection} o que a evolução deste abre algumas possibilidade como a facilidade de aplicar concorrência na evolução com \textit{Lambda} o que atualmente é muito complicado adicionar concorrência em um loop.

