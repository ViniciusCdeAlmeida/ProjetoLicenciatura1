\chapter{Considerações Finais e Trabalhos Futuros}
Este trabalho de conclus\~{a}o concluiu com \^{e}xito o desenvolvimento do analisador est\'{a}tico proposto e este foi utilizado para comprovar a existência de uma grande quantidade  de código duplicado/obsoleto em projetos open-source. Atentando em descobrir o real motivo de tais contru\c{c}\~{o}es de c\'{o}digo, foi realizado contato via e-mail com algumas comunidades de desenvolvimento por\'{e}m somente duas responderam, \textit{Cassandra} e \textit{Maven}, onde pode ser constatado que os desenvolvedores preferem n\~{a}o adotar novas \textit{features} pois utilizam geralmente uma vers\~{a}o mais antiga da JDK relatado em: (http://goo.gl/h0uloY). A altera\c{c}\~{a}o/evolu\c{c}\~{a}o \'{e} realizada em \'{a}reas que s\~{a}o trabalhandas na no dia a dia e n\~{a}o reservando um tempo espec\'{i}fico para realizar uma evolu\c{c}\~{a}o isto foi relatado em: (http://goo.gl/GQ4Ckn). Pode-se concluir que a exist\^{e}ncia de c\'{o}digo duplicado \'{e} dada ao fato das equipes de desenvolvimento n\~{a}o adotarem uma \textit{feature} e ainda por n\~{a}o reservarem tempo para revisar e evoluir um c\'{o}digo desenvolvido anteriormente, sendo realizado apenas uma refatora\c{c}\~{a}o nas parte que consequentemente venham a ser retrabalhadas, isto pode ter como consequ\^{e}ncia direta techos de c\'{o}digo congelados.


Como projeto futuro \'{e} proposto o aproveitamento da arquitetura atual para generalizar este analisador para  outras linguagens como \texttt{C++} em um primeiro momento. Ainda com intu\'{i}to de tornar automatizar a refatora\c{c}\~{a}o pode se acoplar uma linguagem de meta-programação, \texttt{Rascal MPL}, pois estas linguagens s\~{a}o adequadas para realizar o enriquecimento sem\^{a}ntico na realiza\c{c}\~{a}o da refatora\c{c}\~{a}o.

% Para o  linguagem Rascal MPL se destaca tendo em vista que é uma linguagem que atenderia perfeitamente esta evolução dada sua fácil integração com Java e por ser uma linguagem de meta-programação.

%E com isso torna-lo mais especialização deste trabalho para efetuar o \textit{refactoring} de maneira automática seria de grande importância na evolução de código congelado. Com os \textit{visitors} existentes é possível identificar oportunidades reais de empregar \textit{multi-catch} e \textit{swicht com String} o que seria uma evolução. 



%Existe também a possibilidade da extensão do analisador para identificar \textit{multicatch} por similaridade onde atualmente essa tarefa é realizada por igualdade. Com um algoritmo eficiente que detecte a similaridade com certeza a eficiência dessa \textit{feature} irá crescer consideravelmente o que acarretará em um \textit{refactoring} ainda mais significativo.Existe ainda a possibilidade de ampliar a pesquisa para encontrar objetos que contém método \textit{close} dentro de blocos \textit{Try's} o que acarretaria em um outro \textit{refactoring} visando migrar estes objetos para os \textit{resources} que estes pode receber.
%
%Existem diversas características evolutivas da linguagem \textit{Java} a serem atacados tais como \textit{boilerplate} e \textit{anonymousInnerClass} que podem ser tratados com \textit{LambdaExpression}. Um projeto futuro de grande valia seria a evolução desta ferramenta para que obter um \textit{refactoring} automático de códigos ultrapassados assim possibilitando a evolução natural de \textit{softwares} legados e \textit{opensource}.
%
%Como exemplo destes códigos temos o caso de \textit{EnhancedFor} que iteram sobre uma \textit{Collection} o que a evolução deste abre algumas possibilidade como a facilidade de aplicar concorrência na evolução com \textit{Lambda} o que atualmente é muito complicado adicionar concorrência em um loop.

